{"info":{"title":"JavaScript - This","fileName":"js-this","description":"JavaScript 愛恨交織的 this","createdAt":"2025-07-17T00:00:00.000Z","updatedAt":"2025-07-17T00:00:00.000Z","tags":["JavaScript","event handling"]},"content":"<h6>tags: <code>JavaScript</code> <code>front-end</code> <code>this</code></h6>\n<h1 id=\"JavaScript - This\" title=\"JavaScript - This\">JavaScript - This</h1>\n<h2 id=\"this 與前後文本 (context) 綁定的基本四大原則\" title=\"this 與前後文本 (context) 綁定的基本四大原則\"><a href=\"#this 與前後文本 (context) 綁定的基本四大原則\">this 與前後文本 (context) 綁定的基本四大原則</a></h2>\n<ul>\n<li>預設綁定 (Default Binding)</li>\n<li>隱含式綁定 (Implicit Binding)</li>\n<li>顯式綁定 (Explicit Binding)</li>\n<li>「new」關鍵字綁定</li>\n</ul>\n<h3><strong>1. 預設綁定 (Default Binding)</strong></h3>\n<p>意即不屬於任何物件的方法、沒有使用 bind、call、apply 或 new，就套用預設綁定，此時 this 的值就是預設值全域物件，在瀏覽器環境底下是 window。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">a</span> );\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>){\n  <span class=\"hljs-comment\">// this === window</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );\n}\n\n<span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// 123</span>\n</code></pre>\n<p>同樣的情況，若是加上 “use strict” 宣告成嚴格模式後，原本預設將 this 綁定至全域物件的行爲，會轉變成 undefined，因為在 ES5 的嚴格模式下，會禁止 this 自動指定為全域物件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">a</span> );\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>){\n  <span class=\"hljs-string\">&quot;use strict&quot;</span>;\n  <span class=\"hljs-comment\">// this === undefined</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );\n}\n\n<span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span>\n</code></pre>\n<h3><strong>2. 隱含式綁定 (Implicit Binding)</strong></h3>\n<p>即使 function 被宣告的地方是在 global scope 中，只要它成為某個物件的參考屬性 (reference property)，在執行的階段 this 就會被綁定至該物件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">foo</span>: func\n};\n\n<span class=\"hljs-title function_\">func</span>();       <span class=\"hljs-comment\">// undefined</span>\nobj.<span class=\"hljs-title function_\">foo</span>();    <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<p>根據 「預設綁定」的原則，直接呼叫 func() 的情況下，此時的 this.a 實際上會指向 window.a，所以結果是 undefined。</p>\n<p>在 obj 物件中，將 foo 這個屬性指到 func() 的時候，再透過 obj 來呼叫 obj.foo() 的時候，雖然實際上仍是 func() 被呼叫， 但此時的 this 就會指向至 obj 這個 owner 的物件上，於是此時的 this.a 就會是 obj.a 也就是 2 。</p>\n<p>那麼此時，我們宣告另一個變數 func2 指向 obj.foo，猜猜看呼叫 func2() 的結果為何呢？</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">foo</span>: func\n};\n\nobj.<span class=\"hljs-title function_\">foo</span>();  <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-keyword\">var</span> func2 = obj.<span class=\"hljs-property\">foo</span>;\n<span class=\"hljs-title function_\">func2</span>();    <span class=\"hljs-comment\">// ??</span>\n</code></pre>\n<p>答案是 undefined</p>\n<p>當我們宣告 var func2 = obj.foo; 的時候，實際上 func2 就是 window.func2，而你在執行 func2() 的時候，等同於執行 window.func2()，那麼此時的 this 就會是 window。</p>\n<p>決定 this 的關鍵<strong>不在於它屬於哪個物件，而是在於 function「呼叫的時機點」</strong>，當你透過物件呼叫某個方法 (method) 的時候，此時 this 就是那個物件 (owner object)。</p>\n<h3><strong>3. 顯式綁定 (Explicit Binding)。</strong></h3>\n<p>透過 bind() / call() / apply() 這類直接指定 this 的 function 都可被歸類至顯式綁定的類型。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>\n};\n\n<span class=\"hljs-title function_\">func</span>();             <span class=\"hljs-comment\">// undefined</span>\nfunc.<span class=\"hljs-title function_\">call</span>(obj);     <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<h5>「隱含式綁定」與「顯式綁定」衝突時，此時 this 會以「顯式綁定」為主</h5>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> obj1 = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">foo</span>: func };\n\n<span class=\"hljs-keyword\">var</span> obj2 = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">foo</span>: func };\n\n<span class=\"hljs-comment\">// 隱含式綁定</span>\nobj1.<span class=\"hljs-title function_\">foo</span>();  <span class=\"hljs-comment\">// 2</span>\nobj2.<span class=\"hljs-title function_\">foo</span>();  <span class=\"hljs-comment\">// 3</span>\n\n<span class=\"hljs-comment\">// 顯式綁定</span>\nobj1.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">call</span>( obj2 );  <span class=\"hljs-comment\">// 3</span>\nobj2.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">call</span>( obj1 );  <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<h3><strong>4. 「new」關鍵字綁定</strong></h3>\n<p>function 前面帶有 new 被呼叫時，會發生：</p>\n<ul>\n<li>產生一個新的物件 (物件被建構出來)</li>\n<li>this 會指向 new 出來的物件。</li>\n<li>除非這個 function 指定回傳 (return) 了它自己的替代物件，否則這個透過 new 產生的物件會被自動回傳。</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">a</span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = a;\n}\n\n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>( <span class=\"hljs-number\">123</span> );\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( obj.<span class=\"hljs-property\">a</span> );      <span class=\"hljs-comment\">// 123</span>\n</code></pre>\n<h2 id=\"總結\" title=\"總結\"><a href=\"#總結\">總結</a></h2>\n<ul>\n<li>\n<p><strong>判斷順序：</strong></p>\n<ol>\n<li>new 綁定</li>\n<li>顯示綁定</li>\n<li>隱含式綁定</li>\n<li>預設綁定</li>\n</ol>\n</li>\n<li>\n<p><strong>決定 this 是誰的關鍵：</strong></p>\n<ol>\n<li>this 是 function 執行時所屬的物件，this 是在執行時期做綁定，其值和函式在哪裡被呼叫有關</li>\n<li>function 透過 call() 或 apply() 來呼叫時， this 會指向第一個參數，且會立即被執行</li>\n<li>function 透過 bind() 來指定 this</li>\n<li>ES6 箭頭函數內建 .bind() 特性，此時 this 無法複寫。</li>\n</ol>\n</li>\n</ul>\n","toc":{"title":"JavaScript - This","subtitles":["this 與前後文本 (context) 綁定的基本四大原則","總結"]},"wordCount":684}