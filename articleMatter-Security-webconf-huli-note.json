{"info":{"title":"[WebConf 筆記] Huli - 從冷知識到漏洞：你不懂的 Web，駭客懂","fileName":"webconf-huli-note","description":"Huli 大大在 2025 WebConf 演講主題的重點整理筆記","createdAt":"2025-12-14T00:00:00.000Z","updatedAt":"2025-12-14T00:00:00.000Z","tags":["webconf","security"]},"content":"<h6>tags: <code>security</code></h6>\n<h1 id=\"[WebConf 筆記] Huli - 從冷知識到漏洞：你不懂的 Web，駭客懂\" title=\"[WebConf 筆記] Huli - 從冷知識到漏洞：你不懂的 Web，駭客懂\">[WebConf 筆記] Huli - 從冷知識到漏洞：你不懂的 Web，駭客懂</h1>\n<p>這篇是 2025 Webconf 的筆記整理～</p>\n<blockquote>\n<p><a  href=\"https://webconf.tw/agenda/17\" target=\"_blank\" rel=\"noreferrer noopener\">Huli - 從冷知識到漏洞：你不懂的 Web</a> ｜ <a  href=\"https://speakerdeck.com/aszx87410/cong-leng-zhi-shi-dao-lou-dong-ni-bu-dong-de-web-hai-ke-dong-huli-at-webconf-taiwan-2025\" target=\"_blank\" rel=\"noreferrer noopener\">簡報</a> ｜<a  href=\"https://hackmd.io/@webconf/HJiwwqnxZe/%2FkqRzuYEES9-RuzuW0FLsBg\" target=\"_blank\" rel=\"noreferrer noopener\">共筆</a></p>\n</blockquote>\n<p>漏洞分三種</p>\n<ol>\n<li>已知 bug，但時間來不及</li>\n<li>好像有碰過，但忘記了</li>\n<li>不知道這樣寫有問題</li>\n</ol>\n<p>這次例子會聚焦討論第三種～</p>\n<h2 id=\"Case 1. user.email 一定會與 email 相等嗎？\" title=\"Case 1. user.email 一定會與 email 相等嗎？\"><a href=\"#Case 1. user.email 一定會與 email 相等嗎？\">Case 1. user.email 一定會與 email 相等嗎？</a></h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">forgotPassword</span>(<span class=\"hljs-params\">req, res</span>) {\n  <span class=\"hljs-keyword\">const</span> email = req.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">email</span>.<span class=\"hljs-title function_\">toLowerCase</span>();\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">safeSQL</span>(\n    <span class=\"hljs-string\">&quot;select * from users where email = ?&quot;</span>,\n    [email] <span class=\"hljs-comment\">// 用 email 找出 user</span>\n  );\n\n  <span class=\"hljs-keyword\">if</span> (user) {\n    userService\n      .<span class=\"hljs-title function_\">sendResetLink</span>({\n        <span class=\"hljs-attr\">link</span>: userService.<span class=\"hljs-title function_\">generateLink</span>(user.<span class=\"hljs-property\">id</span>),\n        <span class=\"hljs-attr\">to</span>: email <span class=\"hljs-comment\">// 寄重置密碼信給 user</span>\n      })\n      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">204</span>).<span class=\"hljs-title function_\">end</span>();\n}\n</code></pre>\n<p><img src=\"https://hackmd.io/_uploads/ByKbaQeXWl.png\" alt=\"image\" /></p>\n<p><br />\nMySQL 不是直接用「字元的實際編碼值」來比較字串，而是先把字元轉換成 <strong>權重（weight）</strong>，再用權重比較。</p>\n<blockquote>\n<p>不同的 DB 背後比較方式不同，不是每個 DB 都會這樣。</p>\n</blockquote>\n<p><img src=\"https://hackmd.io/_uploads/S14Haml7Wl.png\" alt=\"image\" /></p>\n<h3>如何攻擊？</h3>\n<p><img src=\"https://hackmd.io/_uploads/Hy6Upmg7Zx.png\" alt=\"image\" /></p>\n<p>解法：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">forgotPassword</span>(<span class=\"hljs-params\">req, res</span>) {\n  <span class=\"hljs-keyword\">const</span> email = req.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">email</span>.<span class=\"hljs-title function_\">toLowerCase</span>();\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">safeSQL</span>(\n    <span class=\"hljs-string\">&quot;select * from users where email = ?&quot;</span>,\n    [email] <span class=\"hljs-comment\">// 用 email 找出 user</span>\n  );\n\n  <span class=\"hljs-keyword\">if</span> (user) {\n    userService\n      .<span class=\"hljs-title function_\">sendResetLink</span>({\n        <span class=\"hljs-attr\">link</span>: userService.<span class=\"hljs-title function_\">generateLink</span>(user.<span class=\"hljs-property\">id</span>),\n        <span class=\"hljs-attr\">to</span>: email <span class=\"hljs-comment\">// fix: fix: user.email</span>\n      })\n      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">204</span>).<span class=\"hljs-title function_\">end</span>();\n}\n</code></pre>\n<h3>結論：不同 context 的相等就是不相等</h3>\n<h2 id=\"Case 2. 在 AI 取代人之前，先小心你的字串被取代\" title=\"Case 2. 在 AI 取代人之前，先小心你的字串被取代\"><a href=\"#Case 2. 在 AI 取代人之前，先小心你的字串被取代\">Case 2. 在 AI 取代人之前，先小心你的字串被取代</a></h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> tmpl = <span class=\"hljs-string\">&#x27;&lt;button value=&quot;{{value}}&quot;&gt;click&lt;/button&gt;&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(location.<span class=\"hljs-property\">href</span>).<span class=\"hljs-property\">searchParams</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;v&quot;</span>);\n<span class=\"hljs-keyword\">const</span> safeValue = value.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/[&lt;&gt;&quot;]/g</span>, <span class=\"hljs-string\">&quot;&quot;</span>); <span class=\"hljs-comment\">// 移除特殊字元</span>\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">innerHTML</span> = tmpl.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&quot;{{value}}&quot;</span>, value); <span class=\"hljs-comment\">// 取代</span>\n</code></pre>\n<p><strong>But</strong> ! 這是 JavaScript，當使用在正則表示式（RegExp）中，用「字串」作為取代時，可以使用的特殊替換符號<code>$</code>：</p>\n<p><img src=\"https://hackmd.io/_uploads/HJhYT7em-x.png\" alt=\"image\" /></p>\n<h3>如何攻擊？</h3>\n<p><img src=\"https://hackmd.io/_uploads/Hyt2TQxQbg.png\" alt=\"image\" /></p>\n<p>這是前端典型前端 XSS 攻擊，可以透過 <code>&lt;button&gt;</code> + <code>onClick</code>，塞入想要攻擊的程式碼。</p>\n<h3>結論：字串取代要小心</h3>\n<h2 id=\"Case 3. Clean 不是真的 Clean，Join 不是真的 Join\" title=\"Case 3. Clean 不是真的 Clean，Join 不是真的 Join\"><a href=\"#Case 3. Clean 不是真的 Clean，Join 不是真的 Join\">Case 3. Clean 不是真的 Clean，Join 不是真的 Join</a></h2>\n<h3>Go 的 Clean</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    filename := <span class=\"hljs-string\">&quot;test.js&quot;</span> <span class=\"hljs-comment\">// user-controlled</span>\n    pluginFilePath := filepath.Join(<span class=\"hljs-string\">&quot;/etc/plugins&quot;</span>, filename)\n    fmt.Printf(<span class=\"hljs-string\">&quot;Output: %q/n&quot;</span>, pluginFilePath) <span class=\"hljs-comment\">// /etc/plugins/test.js</span>\n}\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 會往外面資料夾查找</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    filename := <span class=\"hljs-string\">&quot;../../etc/hosts&quot;</span> <span class=\"hljs-comment\">// user-controlled</span>\n    pluginFilePath := filepath.Join(<span class=\"hljs-string\">&quot;/etc/plugins&quot;</span>, filename)\n    fmt.Printf(<span class=\"hljs-string\">&quot;Output: %q/n&quot;</span>, pluginFilePath) <span class=\"hljs-comment\">// /etc/plugins/../../etc/hosts</span>\n}\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    filename := filepath.Clean(<span class=\"hljs-string\">&quot;../../etc/hosts&quot;</span>)\n    pluginFilePath := filepath.Join(<span class=\"hljs-string\">&quot;/etc/plugins&quot;</span>, filename)\n    fmt.Printf(<span class=\"hljs-string\">&quot;Output: %q/n&quot;</span>, pluginFilePath) <span class=\"hljs-comment\">// &quot;/etc/hosts&quot;</span>\n}\n</code></pre>\n<h4>重點：加了 Clean 也一樣會被穿越</h4>\n<p>以為「先 Clean 就安全」，但不對：</p>\n<p>Clean 只是在整理字串，沒有限制結果一定留在 /etc/plugins 底下。</p>\n<blockquote>\n<p>Go - <a  href=\"https://pkg.go.dev/path/filepath#Clean\" target=\"_blank\" rel=\"noreferrer noopener\">Clean Doc</a></p>\n<ol>\n<li>Replace multiple <a  href=\"https://pkg.go.dev/path/filepath#Separator\" target=\"_blank\" rel=\"noreferrer noopener\">Separator</a> elements with a single one.</li>\n<li>Eliminate each . path name element (the current directory).</li>\n<li>Eliminate each <strong>inner … path</strong> name element (the parent directory) along with the non-… element that precedes it.</li>\n<li>Eliminate … elements that <strong>begin a rooted path</strong>: that is, replace “/…” by “/” at the beginning of a path, assuming Separator is ‘/’.</li>\n</ol>\n<p>⇒ filepath.Join 不會限制你一定要留在 /etc/plugins 裡，它只負責算出「合理的路徑」。</p>\n</blockquote>\n<p>如果後面拿 pluginFilePath 去 os.Open / ReadFile，就<strong>不是 plugins，而是系統檔案</strong>，這就是典型目錄穿越 (path traversal) 風險。</p>\n<h4>攻擊例子：<a  href=\"https://github.com/grafana/grafana/security/advisories/GHSA-8pjx-jj86-j47p\" target=\"_blank\" rel=\"noreferrer noopener\">Grafana path traversal</a></h4>\n<p><img src=\"https://hackmd.io/_uploads/SklxA7emZg.png\" alt=\"image\" /></p>\n<p>有其他的 Go 開發者想發 PR 解決這問題，但目前 PR 進度從 2020 年還停留在 In Progress :</p>\n<p><img src=\"https://hackmd.io/_uploads/HJbWAQlQbl.png\" alt=\"image\" /></p>\n<h3>Python 的 Join</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> os\n\nfilename = <span class=\"hljs-string\">&#x27;../../etc/hosts&#x27;</span>\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;..&#x27;</span> <span class=\"hljs-keyword\">in</span> filename:\n    <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&#x27;invalid filename&#x27;</span>)\n\nresult = os.path.join(<span class=\"hljs-string\">&#x27;/tmp/test&#x27;</span>, filename)\n<span class=\"hljs-built_in\">print</span>(result)  <span class=\"hljs-comment\"># ValueError: invalid filename</span>\n</code></pre>\n<p>這個例子在 <code>../</code> 開頭檔案名沒問題，會直接報錯誤，接下來再看看傳入 <code>/etc/hosts</code>，居然不是預期出現的 <code>/tmp/test/etc/hosts</code>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> os\n\nfilename = <span class=\"hljs-string\">&#x27;/etc/hosts&#x27;</span>\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;..&#x27;</span> <span class=\"hljs-keyword\">in</span> filename:\n    <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&#x27;invalid filename&#x27;</span>)\n\nresult = os.path.join(<span class=\"hljs-string\">&#x27;/tmp/test&#x27;</span>, filename)\n<span class=\"hljs-built_in\">print</span>(result)  <span class=\"hljs-comment\"># /etc/hosts</span>\n</code></pre>\n<p>因為在 Python 裡，<code>os.path.join(base, path)</code> 的規則，如果後面的參數是 <strong>絕對路徑</strong>（以 <code>/</code> 開頭），前面的路徑會被 <strong>直接忽略</strong>：</p>\n<blockquote>\n<p><a  href=\"https://arc.net/l/quote/ttslaxed\" target=\"_blank\" rel=\"noreferrer noopener\">os.path.<strong>join</strong>(<em>path</em>, <em>/</em>, <em>*paths</em>)</a></p>\n<p>Join one or more path segments intelligently. The return value is the concatenation of <em>path</em> and all members of <em>*paths</em>, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. <strong>If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment.</strong></p>\n</blockquote>\n<h3>結論：要看官方文件和寫好測試，確保 output 是對的</h3>\n<h2 id=\"Case 4. React is\" title=\"Case 4. React is\"><a href=\"#Case 4. React is\">Case 4. React is</a></h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 把網址 query string（?a=1&amp;b=2）轉成物件</span>\n  <span class=\"hljs-keyword\">const</span> params = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">URLSearchParams</span>(<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">location</span>.<span class=\"hljs-property\">search</span>);\n  <span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(params);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> {<span class=\"hljs-attr\">...obj</span>}&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n}\n</code></pre>\n<h3>如何攻擊？</h3>\n<h4>dangerouslySetInnerHTML ?</h4>\n<p>不會有危險，因為要執行 dangerouslySetInnerHTML 的條件：</p>\n<ol>\n<li>prop 名字 <strong>必須是 <code>dangerouslySetInnerHTML</code></strong></li>\n<li>value <strong>必須是物件</strong></li>\n<li>物件 key <strong>必須是 <code>__html</code></strong></li>\n</ol>\n<pre class=\"hljs\"><code>&lt;div dangerouslySetInnerHTML={{ <span class=\"hljs-attr\">__html</span>: <span class=\"hljs-string\">&quot;&lt;img onerror=alert(1)&gt;&quot;</span> }} /&gt;\n</code></pre>\n<p>例子中 URLSearchParams 的特性是：</p>\n<ol>\n<li>所有值都是字串</li>\n<li>沒有巢狀結構</li>\n</ol>\n<p>即使使用者傳入：</p>\n<pre class=\"hljs\"><code>?dangerouslySetInnerHTML=<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">x</span> <span class=\"hljs-attr\">onerror</span>=<span class=\"hljs-string\">alert(1)</span>&gt;</span>\n</span></code></pre>\n<p>最後變成：</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">dangerouslySetInnerHTML</span>: <span class=\"hljs-string\">&quot;&lt;img src=x onerror=alert(1)&gt;&quot;</span>\n}\n\n<span class=\"hljs-comment\">// React 看到的</span>\n&lt;div dangerouslySetInnerHTML=<span class=\"hljs-string\">&quot;...&quot;</span>&gt;\n</code></pre>\n<p>React 會把它當成「一個普通、未知的 attribute」，<strong>不會執行</strong>。</p>\n<h4>onclick / onClick ?</h4>\n<p><strong><code>onclick</code></strong>：HTML attribute（小寫）在 React 也不會變成可執行事件，只當作一般 attribute。</p>\n<p><img src=\"https://hackmd.io/_uploads/B1wN07xXbl.png\" alt=\"image\" /></p>\n<p><strong><code>onClick</code></strong>：React 事件，<strong>必須是 function</strong>，不能是字串。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 只會是字串</span>\nobj = { <span class=\"hljs-attr\">onClick</span>: <span class=\"hljs-string\">&quot;alert(1)&quot;</span> };\n\n<span class=\"hljs-comment\">// React 看到的</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&quot;alert(1)&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n</code></pre>\n<p><img src=\"https://hackmd.io/_uploads/H1LrRQeXZg.png\" alt=\"image\" /></p>\n<h4>web-component ?</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> obj = {\n    <span class=\"hljs-attr\">is</span>: <span class=\"hljs-string\">&quot;huli&quot;</span>,\n    <span class=\"hljs-attr\">onclick</span>: <span class=\"hljs-string\">&quot;alert(1)&quot;</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> {<span class=\"hljs-attr\">...obj</span>}&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n}\n</code></pre>\n<p>這是 React 為了支援 custom component 而做的邏輯</p>\n<p><img src=\"https://hackmd.io/_uploads/B19dA7xmZx.png\" alt=\"image\" /></p>\n<p>只要加入 is ，就會忽略 L105 的 o/O/n/N 的檢查：</p>\n<p><img src=\"https://hackmd.io/_uploads/rkU5R7lX-x.png\" alt=\"image\" /></p>\n<p>不過在 React 19 版本後改掉了～</p>\n<h3>結論：絕對不要把使用者的輸入照單全收</h3>\n<h2 id=\"Case 5. 小心使用 regex\" title=\"Case 5. 小心使用 regex\"><a href=\"#Case 5. 小心使用 regex\">Case 5. 小心使用 regex</a></h2>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 嘗試判斷字串中是否「看起來像 HTML tag」，用來避免 XSS</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-params\">str</span>) {\n  <span class=\"hljs-comment\">// 只要字串中「同時出現 &lt;，而且後面某處出現 &gt; 或 =」，就當成不安全</span>\n  <span class=\"hljs-keyword\">const</span> regex = <span class=\"hljs-regexp\">/.*[&lt;].*[&gt;=].*/</span>s;\n  <span class=\"hljs-keyword\">return</span> regex.<span class=\"hljs-title function_\">test</span>(str);\n}\n\n<span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-string\">&quot;&lt;svg&gt;&quot;</span>); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-string\">&quot;&lt;svg onload=alert()&quot;</span>); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-string\">&quot;&lt;svg onload=alert()&gt;&quot;</span>); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-string\">&quot;hello &lt;3&quot;</span>); <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<h3>如何攻擊 ？</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-params\">str</span>) {\n  <span class=\"hljs-keyword\">const</span> regex = <span class=\"hljs-regexp\">/.*[&lt;].*[&gt;=].*/</span>s;\n  <span class=\"hljs-keyword\">return</span> regex.<span class=\"hljs-title function_\">test</span>(str);\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">time</span>(<span class=\"hljs-string\">&quot;test&quot;</span>);\n<span class=\"hljs-title function_\">isUnsafeString</span>(<span class=\"hljs-string\">&quot;&lt;svg&gt;&quot;</span> + <span class=\"hljs-string\">&quot;&lt;&quot;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">50000</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">timeEnd</span>(<span class=\"hljs-string\">&quot;test&quot;</span>);\n<span class=\"hljs-comment\">// test: 1.218s</span>\n</code></pre>\n<p>透過設計過的字串，讓正則跑得非常慢，直接卡死主執行緒，這就是 ReDoS(Regular Expression Denial of Service)。</p>\n<blockquote>\n<p>可參考簡報例子的<a  href=\"https://speakerdeck.com/aszx87410/cong-leng-zhi-shi-dao-lou-dong-ni-bu-dong-de-web-hai-ke-dong-huli-at-webconf-taiwan-2025?slide=68\" target=\"_blank\" rel=\"noreferrer noopener\">配對講解</a></p>\n</blockquote>\n<blockquote>\n<p>[補充] 更深入的 ReDoS 文章 - <a  href=\"https://blog.huli.tw/2023/06/12/redos-regular-expression-denial-of-service/\" target=\"_blank\" rel=\"noreferrer noopener\">正規表達式沒寫好會怎樣？淺談 ReDoS：利用 regexp 的攻擊</a></p>\n</blockquote>\n<p>不過<strong>不同的程式語言的配對引擎不同</strong>，效能表現可能差很多：</p>\n<p><strong>Elixir：</strong></p>\n<pre class=\"hljs\"><code>defmodule TimeTest do\n  def is_unsafe_string(str) do\n    Regex.match?(~r/.*[&lt;].*[&gt;=].*/is, str)\n  end\n\n  def run_test do\n    str = &quot;&lt;svg&gt;&quot; &lt;&gt; String.duplicate(&quot;&lt;&quot;, 50_000)\n\n    {time_microseconds, _result} =\n      :timer.tc(fn -&gt; is_unsafe_string(str) end)\n\n    IO.puts(&quot;test: #{time_microseconds / 1_000_000}s&quot;)\n    # 0.098338s\n  end\nend\n\nTimeTest.run_test()\n</code></pre>\n<p><strong>PHP</strong>：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">&lt;?php</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isUnsafeString</span>(<span class=\"hljs-params\"><span class=\"hljs-variable\">$str</span></span>) </span>{\n    <span class=\"hljs-variable\">$regex</span> = <span class=\"hljs-string\">&#x27;/.*[&lt;].*[&gt;=].*/s&#x27;</span>;\n    <span class=\"hljs-keyword\">return</span> preg_match(<span class=\"hljs-variable\">$regex</span>, <span class=\"hljs-variable\">$str</span>);\n}\n\n<span class=\"hljs-variable\">$start</span> = microtime(<span class=\"hljs-literal\">true</span>);\nisUnsafeString(<span class=\"hljs-string\">&#x27;&lt;svg&gt;&#x27;</span> . str_repeat(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>, <span class=\"hljs-number\">50000</span>));\n<span class=\"hljs-variable\">$end</span> = microtime(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-variable\">$time</span> = <span class=\"hljs-variable\">$end</span> - <span class=\"hljs-variable\">$start</span>;\n<span class=\"hljs-keyword\">echo</span> number_format(<span class=\"hljs-variable\">$time</span>, <span class=\"hljs-number\">3</span>) . <span class=\"hljs-string\">&quot;s\\n&quot;</span>;\n<span class=\"hljs-comment\">// 0.001s</span>\n\n<span class=\"hljs-meta\">?&gt;</span>\n</code></pre>\n<p><strong>不過這樣就沒問題了嗎？</strong></p>\n<p>Elixir 實際上它沒有執行完，是設計了一個 backtracking 的上限，到達上限時就不繼續配對。</p>\n<p><img src=\"https://hackmd.io/_uploads/ryenR7emWg.png\" alt=\"image\" /></p>\n<p>PHP 如果正則在運算過程中碰到限制或錯誤（如 backtrack 次數上限），<code>preg_match()</code> 會回傳 <strong><code>false</code></strong>，表示「regex 執行失敗」，而不是「沒匹配」。</p>\n<blockquote>\n<p><a  href=\"https://www.php.net/manual/en/function.preg-match.php#refsect1-function.preg-match-returnvalues\" target=\"_blank\" rel=\"noreferrer noopener\">preg_match() returns 1 if the pattern matches given subject, 0 if it does not, or false on failure.</a></p>\n</blockquote>\n<p><img src=\"https://hackmd.io/_uploads/B1_0Amembl.png\" alt=\"image\" /></p>\n<p>如果程式寫成下方這樣，<strong>攻擊者就可以用超長輸入把 regex 打到失敗，讓檢查「自動放行」</strong>，繞過程式的安全檢查。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!isUnsafeString(<span class=\"hljs-variable\">$input</span>)) {\n  <span class=\"hljs-comment\">// 當成安全</span>\n}\n</code></pre>\n<h3>結論：使用線上 regex checker 或 AI 幫忙</h3>\n<h2 id=\"總結\" title=\"總結\"><a href=\"#總結\">總結</a></h2>\n<ol>\n<li>MySQL unicode =&gt; context 的不相等</li>\n<li>JS replace 時請小心謹慎</li>\n<li>Clean 不是真的 clean，join 不是真的 join</li>\n<li>React is =&gt; 不要全盤相信使用者輸入</li>\n<li>小心使用 regex</li>\n</ol>\n","toc":{"title":"[WebConf 筆記] Huli - 從冷知識到漏洞：你不懂的 Web，駭客懂","subtitles":["Case 1. user.email 一定會與 email 相等嗎？","Case 2. 在 AI 取代人之前，先小心你的字串被取代","Case 3. Clean 不是真的 Clean，Join 不是真的 Join","Case 4. React is","Case 5. 小心使用 regex","總結"]},"wordCount":1759}