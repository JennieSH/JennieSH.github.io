{"info":{"title":"[Note] React Hooks 整理 (上)","fileName":"react-hooks-first","description":"內容為 useState、useEffect、useLayoutEffect、useMemo、useCallback 的整理。","createdAt":"2021-12-08T00:00:00.000Z","updatedAt":"2021-12-08T00:00:00.000Z","tags":["React","React Hooks"]},"content":"<h6>tags: <code>React</code>、<code>React Hooks</code></h6>\n<h1 id=\"[Note] React Hooks 整理（上）\" title=\"[Note] React Hooks 整理（上）\">[Note] React Hooks 整理（上）</h1>\n<p>最近開始學習 React Hooks，趁這次機會整理常見的 Hooks，目前尚缺兩個額外 Hooks (<a  href=\"https://zh-hant.reactjs.org/docs/hooks-reference.html#useimperativehandle\" target=\"_blank\" rel=\"noreferrer noopener\"><code>useImperativeHandle</code></a> &amp; <a  href=\"https://zh-hant.reactjs.org/docs/hooks-reference.html#usedebugvalue\" target=\"_blank\" rel=\"noreferrer noopener\"><code>useDebugValue</code></a>)，內容慢慢增加中 🏃</p>\n<p>&lt;br/&gt;</p>\n<table>\n<thead>\n<tr>\n<th>文章</th>\n<th>Hooks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a  href=\"https://jenniesh.github.io/dev/React/react-hooks-first\" target=\"_blank\" rel=\"noreferrer noopener\">React Hooks 整理 (上)</a></td>\n<td>useState、useEffect、useLayoutEffect、useMemo、useCallback</td>\n</tr>\n<tr>\n<td><a  href=\"https://jenniesh.github.io/dev/React/react-hooks-second\" target=\"_blank\" rel=\"noreferrer noopener\">React Hooks 整理 (下)</a></td>\n<td>useRef、useContext、useReducer</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Why Hook?\" title=\"Why Hook?\"><a href=\"#Why Hook?\">Why Hook?</a></h2>\n<ul>\n<li>更方便在 component 之間共用 stateful 的邏輯</li>\n<li>解決 lifecycle 方法常常將不相關的邏輯混合在一起 e.g. event listener 和抓取資料設置在同個 <code>componentDidMount</code></li>\n<li>降低初學者學習門檻，class 需要記得綁定和事先了解 <code>this</code> 在 JavaScript 中如何運作</li>\n</ul>\n<h2 id=\"Hook 通用規則\" title=\"Hook 通用規則\"><a href=\"#Hook 通用規則\">Hook 通用規則</a></h2>\n<ul>\n<li>只在 <strong>React function componen</strong>t 或<strong>自定義的 Hook</strong> 呼叫 Hook</li>\n<li>只在<strong>最上層</strong>呼叫 Hook：不要在迴圈、判斷式、或是嵌套 function 中呼叫 Hook</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 🚫： 不能放入條件式裡面</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>React<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<h2 id=\"useState\" title=\"useState\"><a href=\"#useState\">useState</a></h2>\n<h3>使用方法</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 語法： const [state, setState] = useState(初始值)</span>\n\n<span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n</code></pre>\n<h3>重點</h3>\n<ul>\n<li>使用陣列解構賦值，回傳的第一個值 <code>count</code> 為當前的 state，第二個值 <code>setCount</code> 為可更新 state 的方法</li>\n<li><code>setState</code> 可直接傳值，也可以傳入 function</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 兩種寫法都有相同效果，一樣都會 +1</span>\n\n<span class=\"hljs-comment\">// 寫法一：直接傳值</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increase</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);\n };\n\n<span class=\"hljs-comment\">// 寫法二： function 可拿到 previous value</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increase</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevCount</span>)=&gt;</span> prevCount + <span class=\"hljs-number\">1</span>);\n};\n</code></pre>\n<details class='spoiler'><summary>setState 補充</summary>\n<div class=\"info\">\n<p><strong>💡 <code>setState</code> 使用 function 時機：<br />\n如果是有使用到 <code>previous value</code> 來設置新的 <code>value</code> 或彼此間有依賴關係。</strong></p>\n<p>雖然上面兩個寫法都可達到 <strong>+1</strong>，但在下面的例子就不適合直接傳值：</p>\n<p><code>increase</code> 內呼叫兩次 <code>setCount</code>，當 <code>increase</code> 被觸發後，我們預期 <code>count</code> 會等於 2，但實際得到 <strong>1</strong>。</p>\n<p>因為 <code>setCount(count + 1)</code>，裡面的 <code>count</code> 都還是當前 render 值 <strong>0</strong>，所以等於執行兩次 <code>setCount(0 + 1)</code>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Count</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// 預期為 2，但實際得到 1</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increase</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 此時 count 為 0，相當於 setCount(0 + 1)</span>\n    <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 此時 count 為 0，相當於 setCount(0 + 1)</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{count}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{increase}</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n\n</code></pre>\n<p>這時改用 function 寫法， 確保是使用 <code>count</code> 的 <code>previous value</code> 而不是當前 render 後的值，就會如預期得到 <strong>2</strong> :</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Count</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increase</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prevCount</span> =&gt;</span> prevCount + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 相當於 setCount(0 + 1)</span>\n    <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prevCount</span> =&gt;</span> prevCount + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 相當於 setCount(1 + 1)</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{count}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{increase}</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n</div>\n</details>\n<p>&lt;br/&gt;</p>\n<ul>\n<li>初始值有兩種表示方式，可直接傳入值，也可以用 function</li>\n</ul>\n<details class='spoiler'><summary>初始值 補充</summary>\n<div class=\"info\">\n<p>💡 <strong>初始值使用 function 寫法的時機：</strong></p>\n<p>因為每次 render 時候都會重新執行 <code>useSate</code>，如果<strong>初始值是需要非常複雜計算時</strong>，每次更新需要重新計算，就會降低效能，這時就需要傳入 function，<strong>該 function 只會在初始 render 時被調用</strong>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 直接傳值：</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">complexCompute</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;execution&quot;</span>);\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Count</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n <span class=\"hljs-comment\">// 每次按 +1 時，都會印出 ‘execution’</span>\n <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-title function_\">complexCompute</span>());\n\n <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increase</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n   <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">preCount</span> =&gt;</span> preCount + <span class=\"hljs-number\">1</span>);\n };\n\n <span class=\"hljs-keyword\">return</span> (\n   <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{count}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{increase}</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n );\n};\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 改用 function</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Count</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-comment\">// 首次渲染印出 ‘execution’，後續按 +1 時，不會在印出字了</span>\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">complexCompute</span>());\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increase</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">preCount</span> =&gt;</span> preCount + <span class=\"hljs-number\">1</span>);\n  };\n\n    ...\n}\n</code></pre>\n</div>\n</details>\n<p>&lt;br/&gt;</p>\n<ul>\n<li><code>setState</code> 是完全覆蓋 state，而非 merge</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 直接整個覆寫 fruitDate</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Fruit</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [fruitDate, setFruitDate] = <span class=\"hljs-title function_\">useState</span>({ <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">fruit</span>: <span class=\"hljs-string\">&quot;banana&quot;</span> });\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">change</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setFruitDate</span>({ <span class=\"hljs-attr\">fruit</span>: <span class=\"hljs-string\">&quot;apple&quot;</span> }); <span class=\"hljs-comment\">// 觸發後，fruitDate 為 { fruit: &quot;apple&quot; }</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{change}</span>&gt;</span>change fruit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n};\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 使用擴展運算子，保留物件內其他屬性</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Fruit</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [fruitDate, setFruitDate] = <span class=\"hljs-title function_\">useState</span>({ <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">fruit</span>: <span class=\"hljs-string\">&quot;banana&quot;</span> });\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">change</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">setFruitDate</span>({ ...fruitData, <span class=\"hljs-attr\">fruit</span>: <span class=\"hljs-string\">&quot;apple&quot;</span> }); <span class=\"hljs-comment\">// 觸發後，fruitDate 為 { amount: 1 fruit: &quot;apple&quot; }</span>\n  };\n\n  ...\n};\n</code></pre>\n<h2 id=\"useEffect\" title=\"useEffect\"><a href=\"#useEffect\">useEffect</a></h2>\n<h3>使用方法</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 語法： useEffect(()=&gt;{},[依賴項])</span>\n\n<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// 每次畫面重新渲染後都會執行</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;executed&quot;</span>)\n});\n</code></pre>\n<h3>重點</h3>\n<ul>\n<li>處理 side effect 事件，e.g. ajax、EventLister</li>\n<li>DOM 改變 =&gt; 渲染畫面 =&gt; 調用 <code>useEffect</code></li>\n<li>可以有多個依賴項，皆放在陣列中 <code>useEffect(()=&gt;{ ... },[a, b, c])</code></li>\n<li>搭配第二參數傳入依賴和 return function，可達到原先 React 生命週期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的效果</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Fruit</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [fruit, setFruit] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&quot;banana&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// A. 第二參數不帶入，每次畫面重新渲染，都會執行</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// 當 fruit 或 count 值改變，畫面重新渲染，都會印出 “changed”</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;changed&quot;</span>);\n  });\n\n\n  <span class=\"hljs-comment\">// B. 第二參數，傳入空陣列 []，只有在第一次渲染時執行</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// 只在第一次渲染會印出 &quot;init&quot;</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;init&quot;</span>);\n  }, []);\n\n\n  <span class=\"hljs-comment\">// C. 第二參數，傳入依賴項，只有在依賴項改變時才執行</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// 只有 count 值改變，畫面更新，才會印出 &quot;count changed&quot;</span>\n    <span class=\"hljs-comment\">// 如果是 fruit 值改變則不觸發</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;count changed&quot;</span>);\n  }, [count]);\n\n\n  <span class=\"hljs-comment\">// D. return 的 function 會在組件移除後會觸發</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// 初次渲染時，建立 setInterval</span>\n    <span class=\"hljs-keyword\">const</span> timer = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n\n    <span class=\"hljs-comment\">// 在組件移除後會執行 clearInterval</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(timer);\n  }, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setFruit(&quot;apple&quot;)}&gt;change fruit - {fruit}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>;\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setCount(prev =&gt; prev + 1)}&gt;increase count - {count}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>;\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n<h2 id=\"useLayoutEffect\" title=\"useLayoutEffect\"><a href=\"#useLayoutEffect\">useLayoutEffect</a></h2>\n<h3>使用方法</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 語法： useLayoutEffect(()=&gt;{},[依賴項])</span>\n\n<span class=\"hljs-title function_\">useLayoutEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n     <span class=\"hljs-comment\">// 每次畫面重新渲染前都會執行</span>\n     <span class=\"hljs-comment\">// 對 DOM 操作 ....</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;executed&quot;</span>)\n});\n</code></pre>\n<h3>重點</h3>\n<ul>\n<li>DOM 改變 =&gt; 調用 <code>useLayoutEffect</code> =&gt; 渲染畫面</li>\n<li>謹慎使用，會影響使用者體驗，因為需要等待 <code>useLayoutEffect</code> 內程式實行完，才會渲染出畫面</li>\n<li>使用時機：需要基於 DOM 的 Layout 做額外操作 e.g. 測量 DOM</li>\n</ul>\n<h3>範例 (useEffect v.s. useLayoutEffect)</h3>\n<h4>- 使用 useEffect</h4>\n<p>在慢動作的 gif 裡面可以看到一開始的 <code>hi</code> (<code>top: 0</code>) 先出現在按鈕旁邊，在下一個畫面才套用 <code>top: 100px</code>，如果用正常速度看，就會看到第一個 hi 會閃爍一下，這對使用者體驗很不好。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 使用 useEffect</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Foo</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [show, setShow] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> greetRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (greetRef.<span class=\"hljs-property\">current</span> === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span>;\n\n    (greetRef.<span class=\"hljs-property\">current</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">HTMLSpanElement</span>).<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = <span class=\"hljs-string\">&quot;100px&quot;</span>;\n  }, [show]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setShow(prev =&gt; !prev)}&gt; toggle Button<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      {show &amp;&amp; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{greetRef}</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">position:</span> &quot;<span class=\"hljs-attr\">absolute</span>&quot; }}&gt;</span>\n          hi\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      )}\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n<p><img src=\"https://i.imgur.com/gGzLETq.gif\" alt=\"useEffect\" /></p>\n<h4>- 使用 useLayoutEffect</h4>\n<p>因為在渲染畫面前，先執行完好 <code>hi</code> 的 <code>top: 100px</code>，所以在看到畫面時，已經所設定的位置上了。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 使用 useLayoutEffect</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Foo</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [show, setShow] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> greetRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-title function_\">useLayoutEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (greetRef.<span class=\"hljs-property\">current</span> === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span>;\n\n    (greetRef.<span class=\"hljs-property\">current</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">HTMLSpanElement</span>).<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = <span class=\"hljs-string\">&quot;100px&quot;</span>;\n  }, [show]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setShow(prev =&gt; !prev)}&gt; toggle Button<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      {show &amp;&amp; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{greetRef}</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">position:</span> &quot;<span class=\"hljs-attr\">absolute</span>&quot; }}&gt;</span>\n          hi\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      )}\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n<p><img src=\"https://i.imgur.com/k5IHSoW.gif\" alt=\"useLayoutEffect\" /></p>\n<h2 id=\"useMemo\" title=\"useMemo\"><a href=\"#useMemo\">useMemo</a></h2>\n<h3>使用方法</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 語法： const data = useMemo(()=&gt;{ return 值 },[依賴項])</span>\n\n<span class=\"hljs-keyword\">const</span> memoizedValue = <span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">computeExpensiveValue</span>(a, b), [a, b]);\n</code></pre>\n<ul>\n<li>可以將<strong>函式返回值 cached</strong>（跟 Vue 的 computed 很像)，並回傳一個 <a  href=\"https://en.wikipedia.org/wiki/Memoization\" target=\"_blank\" rel=\"noreferrer noopener\">memoized</a> 的值</li>\n<li>useMemo 的 function 會在 render 期間執行</li>\n<li>可傳入依賴 array，當依賴改變時才重新計算，不提供則每次都計算</li>\n<li>需額外記憶體儲存變數，相當於以空間換時間，所以簡單的計算 / 值，要避免濫用</li>\n<li>使用情境：當值需要昂貴計算得到，但不需要每次 render 都進行重新計算，可使用 useMemo 來優化</li>\n</ul>\n<h3>範例</h3>\n<p>由於每次畫面更新渲染都會執行 <code>slowFunc</code>，即使我們只想 toggle theme 時，還是要等待 for 迴圈結束，導致 dark theme 的畫面更新會有延遲。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 模擬複雜計算</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">slowFunc</span> = (<span class=\"hljs-params\">num</span>) =&gt; {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">1000000000</span>; i++) {}\n  <span class=\"hljs-keyword\">return</span> num * <span class=\"hljs-number\">2</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Fruit</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [num, setNumber] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [dark, setDark] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> doubleNumber = <span class=\"hljs-title function_\">slowFunc</span>(num); <span class=\"hljs-comment\">// 每次渲染都會執行</span>\n  <span class=\"hljs-keyword\">const</span> theme = {\n    <span class=\"hljs-attr\">color</span>: dark ? <span class=\"hljs-string\">&quot;white&quot;</span> : <span class=\"hljs-string\">&quot;black&quot;</span>,\n    <span class=\"hljs-attr\">backgroundColor</span>: dark ? <span class=\"hljs-string\">&quot;black&quot;</span> : <span class=\"hljs-string\">&quot;white&quot;</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;number&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{num}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{e</span> =&gt;</span> setNumber(parseInt(e.target.value))} /&gt;\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{doubleNumber}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setDark(!dark)} style={theme}&gt;\n        toggle theme\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n<p>使用 useMemo 改寫並指定依賴後，在 toggle theme 就不會再進入 for 迴圈，能及時變更顏色了</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">slowFunc</span> = (<span class=\"hljs-params\">num</span>) =&gt; {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">1000000000</span>; i++) {}\n  <span class=\"hljs-keyword\">return</span> num * <span class=\"hljs-number\">2</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Fruit</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [num, setNumber] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [dark, setDark] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-comment\">// 指定 num 為依賴的值，只有 num 改變值，才呼叫 slowFunc</span>\n  <span class=\"hljs-keyword\">const</span> doubleNumber = <span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">slowFunc</span>(num), [num]);\n  <span class=\"hljs-keyword\">const</span> theme = {\n    <span class=\"hljs-attr\">color</span>: dark ? <span class=\"hljs-string\">&quot;white&quot;</span> : <span class=\"hljs-string\">&quot;black&quot;</span>,\n    <span class=\"hljs-attr\">backgroundColor</span>: dark ? <span class=\"hljs-string\">&quot;black&quot;</span> : <span class=\"hljs-string\">&quot;white&quot;</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> (...);\n};\n</code></pre>\n<h2 id=\"useCallback\" title=\"useCallback\"><a href=\"#useCallback\">useCallback</a></h2>\n<h3>使用方法</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 語法： const cb = useCallback(callback, [依賴項])</span>\n\n<span class=\"hljs-keyword\">const</span> memoizedCallback = <span class=\"hljs-title function_\">useCallback</span>(\n  <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">doSomething</span>(a, b);\n  },\n  [a, b],\n);\n</code></pre>\n<ul>\n<li>與 <code>useMemo</code> 概念大致相同，<strong><code>useMemo</code></strong> 儲存 function <strong>return 回來的值</strong>，<strong><code>useCallback</code></strong> 儲存<strong>整個 function</strong>，<code>useCallback(fn, deps)</code> 相等於 <code>useMemo(() =&gt; fn, deps)</code></li>\n<li>可傳入依賴 array，當依賴改變時才重新宣告跟建立 function</li>\n<li>使用情境：當子組件有依賴父組件傳遞 function，父組件的 function 可使用 <code>useCallback</code> 優化，來防止不必要的 render</li>\n</ul>\n<h3>範例</h3>\n<p>當每次 Parent Component(<code>&lt;Foo&gt;</code>)的 <code>num</code> 或 <code>dark</code> 值變動時， 畫面會重新渲染，<code>&lt;Foo&gt;</code> 內的 <code>getItems</code> 也跟著被重新宣告跟建立，等於 Child Component(<code>&lt;List&gt;</code>) 每次接收不同的 <code>getItems</code>，也跟著重新渲染（即使值不變，只有 <code>dark</code> 變動的情境）。</p>\n<h4>- 不使用 useCallback</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Child Component</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">List</span> = (<span class=\"hljs-params\">{ getItems }</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [items, setItems] = <span class=\"hljs-title function_\">useState</span>([]);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">setItems</span>(<span class=\"hljs-title function_\">getItems</span>());\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;executed&quot;</span>); <span class=\"hljs-comment\">// num 或 dark 值變動時，&lt;List&gt; 都會 rerender，印出 executed</span>\n  }, [getItems]);\n\n  <span class=\"hljs-keyword\">return</span> items.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{item}</span>&gt;</span>{item}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>);\n};\n\n<span class=\"hljs-comment\">// Parent Component</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Foo</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [num, setNumber] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> [dark, setDark] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-comment\">// 一般宣告函式</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getItems</span> = (<span class=\"hljs-params\"></span>) =&gt; [num, num + <span class=\"hljs-number\">1</span>, num + <span class=\"hljs-number\">2</span>];\n\n  <span class=\"hljs-keyword\">const</span> theme = {\n    <span class=\"hljs-attr\">color</span>: dark ? <span class=\"hljs-string\">&quot;white&quot;</span> : <span class=\"hljs-string\">&quot;black&quot;</span>,\n    <span class=\"hljs-attr\">backgroundColor</span>: dark ? <span class=\"hljs-string\">&quot;black&quot;</span> : <span class=\"hljs-string\">&quot;white&quot;</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;number&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{num}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{e</span> =&gt;</span> setNumber(parseInt(e.target.value))} /&gt;\n\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setDark(prev =&gt; !prev)} style={theme}&gt;\n        toggle theme\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span> <span class=\"hljs-attr\">getItems</span>=<span class=\"hljs-string\">{getItems}</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n<h4>- 使用 useCallback</h4>\n<p>使用 useCallback，並傳入 <code>num</code> 當作依賴項，接下來當 <code>num</code> 值改變時，<code>getItems</code> 這個 function 才會重新被建立。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Child Component</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">List</span> = (<span class=\"hljs-params\">{ getItems }: { getItems: () =&gt; number[] }</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [items, setItems] = useState&lt;number[]&gt;([]);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">setItems</span>(<span class=\"hljs-title function_\">getItems</span>());\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;executed&quot;</span>); <span class=\"hljs-comment\">// 只有在 num 值變動時，才印出 executed</span>\n  }, [getItems]);\n\n  <span class=\"hljs-keyword\">return</span> items.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{item}</span>&gt;</span>{item}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>);\n};\n\n<span class=\"hljs-comment\">// Parent Component</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Foo</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [num, setNumber] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> [dark, setDark] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-comment\">// 使用 useCallback</span>\n  <span class=\"hljs-keyword\">const</span> getItems = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> [num, num + <span class=\"hljs-number\">1</span>, num + <span class=\"hljs-number\">2</span>], [num]);\n\n  <span class=\"hljs-keyword\">const</span> theme = { ... };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;number&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{num}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{e</span> =&gt;</span> setNumber(parseInt(e.target.value))} /&gt;\n\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setDark(prev =&gt; !prev)} style={theme}&gt;\n        toggle theme\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span> <span class=\"hljs-attr\">getItems</span>=<span class=\"hljs-string\">{getItems}</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n};\n</code></pre>\n<h2 id=\"參考資料\" title=\"參考資料\"><a href=\"#參考資料\">參考資料</a></h2>\n<ol>\n<li><a  href=\"https://reactjs.org/docs/getting-started.html\" target=\"_blank\" rel=\"noreferrer noopener\">React 官方文件</a></li>\n<li><a  href=\"https://www.youtube.com/playlist?list=PLZlA0Gpn_vH8EtggFGERCwMY5u5hOjf-h\" target=\"_blank\" rel=\"noreferrer noopener\">Web Dev Simplified - React Hooks</a></li>\n</ol>\n","toc":{"title":"[Note] React Hooks 整理（上）","subtitles":["Why Hook?","Hook 通用規則","useState","useEffect","useLayoutEffect","useMemo","useCallback","參考資料"]}}