{"info":{"title":"[Note] 瀏覽器渲染頁面的流程","fileName":"browser-rendering","description":"網頁畫面如何無中生有","createdAt":"2025-09-17T00:00:00.000Z","updatedAt":"2025-09-17T00:00:00.000Z","tags":["browser"]},"content":"<h6>tags: <code>browser</code></h6>\n<h1 id=\"[Note] 瀏覽器渲染頁面的流程\" title=\"[Note] 瀏覽器渲染頁面的流程\">[Note] 瀏覽器渲染頁面的流程</h1>\n<blockquote>\n<p>本文章圖片皆截圖於 <a  href=\"https://www.bilibili.com/video/BV18f4y1H7Zu?spm_id_from=333.999.0.0\" target=\"_blank\" rel=\"noreferrer noopener\">浏览器渲染页面的流程</a></p>\n</blockquote>\n<h2 id=\"流程圖\" title=\"流程圖\"><a href=\"#流程圖\">流程圖</a></h2>\n<p><img src=\"https://i.imgur.com/ekgRij6.png\" alt=\"流程圖\" /></p>\n<ul>\n<li>依據 JS 有無額外的設置，默認要等 CSSOM 構建完成</li>\n<li>如果 JS 有修改到 DOM/CSSOM，後面三步驟會在執行一次</li>\n</ul>\n<h2 id=\"DOM\" title=\"DOM\"><a href=\"#DOM\">DOM</a></h2>\n<p>先請求 Server 得到 HTML 文件，會先得到字節版的 HTML，接著轉化開發人員平常熟悉的字符版，接著瀏覽器會再轉成機器看得懂的 Token 版本(Token = 符號標籤)，即將字符 <code>Token 化</code>，不同字符就會變得有不同的特殊意義。</p>\n<blockquote>\n<p>因 HTML 是標記語言，裡面有很多 <code>&lt;</code>、<code>&gt;</code>，可以用來識別不同的結構，</p>\n</blockquote>\n<p>這些 Token 會轉變成物件，可視為是一個節點，這些物件都有自己的屬性和方法，將這些節點連接起來就成為一個樹狀的結構，即為 DOM(文件物件模型)。</p>\n<p>DOM 可以理解爲是瀏覽器自己的語言，因為樹狀的結構關係，每個節點相連會形成父子關係(Parent and Child)和兄弟關係(Siblings)。</p>\n<p><img src=\"https://i.imgur.com/RB80abq.png\" alt=\"DOM\" /></p>\n<h2 id=\"CSSOM\" title=\"CSSOM\"><a href=\"#CSSOM\">CSSOM</a></h2>\n<blockquote>\n<p>CSS 解析可以與 DOM 解析同進行</p>\n</blockquote>\n<p>通常 CSS 樣式會以 <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;index.css&quot;&gt;</code> 放在 HTML 的 <code>&lt;head&gt;</code> 中，所以當瀏覽器在解析構建 DOM 時，遇到 <code>&lt;link&gt;</code> 標籤，會向 Server 發起 request 取得 css 檔案。</p>\n<p>拿到檔案後跟解析 HTML 差不多，一樣先把字節轉字符再轉成 token，token 在轉換成節點，唯一不一樣是最後一步，節點最後會結合為 CSS 物件模型，即為 CSSOM。</p>\n<p><img src=\"https://i.imgur.com/BQoFSLx.png\" alt=\"CSSOM\" /></p>\n<h2 id=\"Rendering Tree - 渲染樹\" title=\"Rendering Tree - 渲染樹\"><a href=\"#Rendering Tree - 渲染樹\">Rendering Tree - 渲染樹</a></h2>\n<p>會匹配 DOM 和 CSSOM 的節點，留下可見元素，即螢幕上顯示的所有可見內容，同時也包含相應的樣式資訊。</p>\n<ul>\n<li>HTML DOM: 只留下 <code>&lt;body&gt;</code> 內容，<code>&lt;head&gt;</code> 不會被渲染到畫面上</li>\n<li>CSSOM: 會濾掉 <code>display: none</code> 等樣式</li>\n</ul>\n<p><img src=\"https://i.imgur.com/pcZuuCO.png\" alt=\"渲染樹\" /></p>\n<h2 id=\"Layout - 佈局\" title=\"Layout - 佈局\"><a href=\"#Layout - 佈局\">Layout - 佈局</a></h2>\n<p>獲取渲染樹的結構、節點位置和大小，計算每個可視元素的版面配置。</p>\n<p>佈局過程依據「盒子模型」進行，這個模型可精確說明每個元素在畫面中的準確位置和大小: 所有相對度量單位都會轉換為螢幕上的絕對像素位置。</p>\n<p><img src=\"https://i.imgur.com/5NqyDD5.png\" alt=\"佈局\" /></p>\n<h2 id=\"Paint - 繪製\" title=\"Paint - 繪製\"><a href=\"#Paint - 繪製\">Paint - 繪製</a></h2>\n<p>佈局完成後，瀏覽器會觸發「Paint Setup」和「Paint」事件，將渲染樹轉化為螢幕上的實際像素。</p>\n<h2 id=\"渲染 HTML + CSS + JS\" title=\"渲染 HTML + CSS + JS\"><a href=\"#渲染 HTML + CSS + JS\">渲染 HTML + CSS + JS</a></h2>\n<p><strong>JS 與 CSS</strong><br />\n如果 JS 文件較 CSS 文件先返回並解析執行完成，會發生阻塞，所以不能先執行 JS 文件，且 JS 可操控 CSSOM，所以需要等 <strong>CSSOM 構建完成才能執行 JS 文件</strong>，但可以先進行解析 JS 文件</p>\n<p><strong>JS 與 HTML</strong><br />\nJS 會間接阻塞 HTML 解析，因為 JS 可操控 DOM，如果不等 JS 執行完，先解析 DOM 且會繪製出來，可能會造成網頁內容出現了又消失，所以需要等 JS 解析執行完再構建 DOM（指 <code>&lt;/script&gt;</code> 後的 DOM）。</p>\n<p><img src=\"https://i.imgur.com/B8qRuW8.png\" alt=\"渲染 HTML + CSS + JS\" /></p>\n<p>在執行 JS 完成前，畫面是沒有東西的，直到 JS 執行完成後，繼續完成後續 DOM 解析，直到畫面被繪製出來。</p>\n<blockquote>\n<p>JS 檔案有設置 Async<br />\n<img src=\"https://i.imgur.com/nSNOLw3.png\" alt=\"JS Async\" /></p>\n</blockquote>\n<h3><code>&lt;script&gt;</code> 標籤 defer 和 async 的區別</h3>\n<p><strong>兩者皆只適用於外部腳本</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>defer</th>\n<th>async</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>場景</td>\n<td>與 DOM 關聯的腳本</td>\n<td>第三方腳本</td>\n</tr>\n<tr>\n<td>阻塞 HTML 解析</td>\n<td>不阻塞</td>\n<td>不阻塞</td>\n</tr>\n<tr>\n<td>執行時間</td>\n<td>會等 HTML 解析完才執行</td>\n<td>加載後會立即執行</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://i.imgur.com/zOadq3e.png\" alt=\"\" /></p>\n<div class=\"info\">\n<p><strong>💡補充</strong></p>\n<ul>\n<li>DOM\n<blockquote>\n<p>但可以部分解析</p>\n</blockquote>\n</li>\n<li>CSSOM\n<blockquote>\n<p>不能部分解析，會造成樣式災難，因為樣式會後蓋前或權重問題，所以真正呈現的樣式會以解析完整份 css 檔案為主。<br />\n<img src=\"https://i.imgur.com/ZPH0yfQ.png\" alt=\"CSSOM 全部解析\" /></p>\n</blockquote>\n</li>\n</ul>\n</div>\n<h2 id=\"優化\" title=\"優化\"><a href=\"#優化\">優化</a></h2>\n<p><strong>瀏覽器執行的所有步驟：</strong></p>\n<ol>\n<li>處理 HTML 標記，產生 DOM 樹狀結構</li>\n<li>處理 CSS 標記，產生 CSSOM 樹狀結構</li>\n<li>將 DOM 樹狀結構和 CSSOM 樹狀結構合併為渲染樹 (Render-tree)</li>\n<li>對渲染樹進行版面配置，計算每個節點的幾何形狀</li>\n<li>在螢幕上繪製各個節點</li>\n</ol>\n<p>能讓使用者更快看到畫面內容，重點就是儘可能<strong>縮短上述第 1 步到第 5 步所花費的總時間</strong></p>\n<h2 id=\"參考\" title=\"參考\"><a href=\"#參考\">參考</a></h2>\n<ol>\n<li><a  href=\"https://www.bilibili.com/video/BV18f4y1H7Zu?spm_id_from=333.999.0.0\" target=\"_blank\" rel=\"noreferrer noopener\">浏览器渲染页面的流程</a></li>\n<li><a  href=\"https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/719042/\" target=\"_blank\" rel=\"noreferrer noopener\">渲染樹的形成原理你真的很懂嗎?</a></li>\n<li><a  href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-tw\" target=\"_blank\" rel=\"noreferrer noopener\">轉譯樹狀結構的建構、版面配置和繪製</a></li>\n</ol>\n","toc":{"title":"[Note] 瀏覽器渲染頁面的流程","subtitles":["流程圖","DOM","CSSOM","Rendering Tree - 渲染樹","Layout - 佈局","Paint - 繪製","渲染 HTML + CSS + JS","優化","參考"]},"wordCount":576}