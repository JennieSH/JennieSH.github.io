{"info":{"title":"Vitest - DOM 測試","fileName":"vitest-dom","description":"DOM 測試注意事項","createdAt":"2024-12-15T00:00:00.000Z","updatedAt":"2024-12-15T00:00:00.000Z","tags":["Test","Vitest","dom","jest-dom","user-event"]},"content":"<h1 id=\"Vitest - DOM 測試\" title=\"Vitest - DOM 測試\">Vitest - DOM 測試</h1>\n<h2 id=\"Setup\" title=\"Setup\"><a href=\"#Setup\">Setup</a></h2>\n<h3>安裝套件</h3>\n<p>以 React 來說，如果要進一步測試元件，除了 Vitest 本身，還需要安裝其他套件，才能解析 React 元件和模擬互動：</p>\n<ol>\n<li>\n<p><a  href=\"https://www.npmjs.com/package/jsdom\" target=\"_blank\" rel=\"noreferrer noopener\">jsdom</a> / <a  href=\"https://www.npmjs.com/package/happy-dom\" target=\"_blank\" rel=\"noreferrer noopener\">happy-dom</a>：提供 Browser API 模擬瀏覽器環境</p>\n<ul>\n<li>jsdom ： 功能較完善穩定，速度相較於 happy-dom 慢</li>\n<li>happy-dom ： 輕量級，執行速度較快，但缺少一些 API</li>\n</ul>\n</li>\n<li>\n<p><a  href=\"https://www.npmjs.com/package/@testing-library/react\" target=\"_blank\" rel=\"noreferrer noopener\">testing-library/react</a>(RTL)：用於測試 React 組件的渲染和交互</p>\n</li>\n<li>\n<p><a  href=\"https://www.npmjs.com/package/@testing-library/dom\" target=\"_blank\" rel=\"noreferrer noopener\">testing-library/dom</a>：為 Testing Library 的核心，提供查詢 DOM 方法和模擬用戶行為(fireEvent)</p>\n<blockquote>\n<p><strong>補充：</strong> RTL v16 後，<code>testing-library/dom</code> 需要一起安裝。</p>\n</blockquote>\n</li>\n</ol>\n <br>\n<pre class=\"hljs\"><code>npm install -D jsdom @testing-library/react @testing-library/dom\n\n<span class=\"hljs-comment\"># 如果沒有的話，需要安裝，用來支援 React</span>\n\nnpm install -D @vitejs/plugin-react\n\n</code></pre>\n<blockquote>\n<p><strong>補充：</strong> 如果專案沒有 <code>@vitejs/plugin-react</code> 也需要安裝，用來處理 React 相關的文件和功能。</p>\n</blockquote>\n<h3>設置設定檔</h3>\n<p>在 <code>vite.config.ts</code> 設定：</p>\n<ol>\n<li>設定 plugin 設定 (如果專案是用 vite 起的，這段建立時就會有了)</li>\n<li>設定執行的環境</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// vite.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { defineConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vite&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> react <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@vitejs/plugin-react&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>({\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-title function_\">react</span>()], <span class=\"hljs-comment\">// 1. 新增 plugin 設定</span>\n  <span class=\"hljs-attr\">test</span>: {\n    <span class=\"hljs-attr\">environment</span>: <span class=\"hljs-string\">&quot;jsdom&quot;</span>, <span class=\"hljs-comment\">// 2. 指定 environment</span>\n    }\n  }\n});\n</code></pre>\n<h2 id=\"原則\" title=\"原則\"><a href=\"#原則\">原則</a></h2>\n<ol>\n<li>當內部邏輯過於複雜時，可以抽出邏輯變成 hook，<strong>元件就專注於測試本身行為</strong>，另外對 hook 做邏輯測試</li>\n<li>以<strong>使用者角度關注元件</strong>上預期的結果</li>\n<li>元件有呼叫到 API 時，測試專注於元件接受到內容的渲染結果或行為，API 返回資料可以透過 mock 方式提供，確認元件有符合預期即可</li>\n</ol>\n<h2 id=\"常用 API\" title=\"常用 API\"><a href=\"#常用 API\">常用 API</a></h2>\n<h3><strong><code>render</code></strong></h3>\n<p>將 React 元件或組件渲染到虛擬 DOM 中，使測試能夠在瀏覽器環境模擬中運行。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;render a component&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Click Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>);\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)).<span class=\"hljs-title function_\">toBeInTheDocument</span>();\n});\n</code></pre>\n<p>在不重新建立測試環境的情況下，可以使用 <code>rerender</code> 更新已渲染的元件，<strong>適合測試相同元件在不同屬性或狀態下的行為</strong></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> { rerender } = <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">NumberDisplay</span> <span class=\"hljs-attr\">number</span>=<span class=\"hljs-string\">{1}</span> /&gt;</span></span>);\n\n<span class=\"hljs-comment\">// re-render the same component with different props</span>\n<span class=\"hljs-title function_\">rerender</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">NumberDisplay</span> <span class=\"hljs-attr\">number</span>=<span class=\"hljs-string\">{2}</span> /&gt;</span></span>);\n</code></pre>\n<h3><strong><code>screen</code></strong></h3>\n<p>提供一個全局訪問虛擬 DOM 的 API。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;use screen to find an element&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;Enter your name&quot;</span> /&gt;</span></span>);\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByPlaceholderText</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>)).<span class=\"hljs-title function_\">toBeInTheDocument</span>();\n});\n</code></pre>\n<h3><strong><code>getByRole</code></strong></h3>\n<p>用來根據元素的 <code>角色</code> 屬性來查找節點，例如按鈕、標題等，官方推薦優先使用，幾乎可以涵蓋所有需求。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;get element by role&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>);\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByRole</span>(<span class=\"hljs-string\">&quot;button&quot;</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Submit&quot;</span> })).<span class=\"hljs-title function_\">toBeInTheDocument</span>();\n});\n</code></pre>\n<blockquote>\n<p><strong>補充：</strong></p>\n<ul>\n<li>節點查找 API 選擇 @<a  href=\"https://testing-library.com/docs/queries/about#priority\" target=\"_blank\" rel=\"noreferrer noopener\">Which query should I use?</a></li>\n<li>MDN 的 Roles @<a  href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#Roles\" target=\"_blank\" rel=\"noreferrer noopener\">list of roles</a></li>\n</ul>\n</blockquote>\n<h3><strong><code>getByText</code></strong></h3>\n<p>根據元素內的文本來查找節點，<strong>找不到元素會拋出錯誤</strong>，適合用於<strong>尋找特定顯示文本</strong>的元素，。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;get element by text&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello World<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>);\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)).<span class=\"hljs-title function_\">toBeInTheDocument</span>();\n});\n</code></pre>\n<h3><strong><code>queryByText</code></strong></h3>\n<p>與 <code>getByText</code> 類似，但如果<strong>找不到元素時</strong>，不會拋出錯誤，而是<strong>返回 <code>null</code></strong>，<strong>適合用於確認元素是否不存在</strong>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;query element by text&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello World<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>);\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">queryByText</span>(<span class=\"hljs-string\">&quot;Goodbye&quot;</span>)).<span class=\"hljs-title function_\">toBeNull</span>();\n});\n</code></pre>\n<h3><strong><code>fireEvent</code></strong></h3>\n<p>用來手動觸發 DOM 事件來<strong>模擬使用者行為</strong>的方法，例如 <code>click</code> 或 <code>input</code> 事件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;fire a click event&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> handleClick = vi.<span class=\"hljs-title function_\">fn</span>();\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleClick}</span>&gt;</span>Click Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>);\n  fireEvent.<span class=\"hljs-title function_\">click</span>(screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>));\n  <span class=\"hljs-title function_\">expect</span>(handleClick).<span class=\"hljs-title function_\">toHaveBeenCalled</span>();\n});\n</code></pre>\n<h3><strong><code>cleanup</code></strong></h3>\n<p>在每個測試後清除渲染的 DOM，<strong>防止測試之間的狀態污染</strong>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">afterEach</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">cleanup</span>();\n});\n</code></pre>\n<blockquote>\n<p><strong>補充：</strong> 搭配 Vitest 的設定參考 @<a  href=\"https://arc.net/l/quote/bajthlbg\" target=\"_blank\" rel=\"noreferrer noopener\">Auto Cleanup in Vitest </a></p>\n</blockquote>\n<h3><strong><code>renderHook</code></strong></h3>\n<p>用來<strong>測試 React 自訂 Hook 的函式</strong>。它將 Hook 渲染在虛擬環境中，使開發者能驗證其邏輯和行為。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;returns logged in user&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> { result } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">useLoggedInUser</span>());\n  <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>).<span class=\"hljs-title function_\">toEqual</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span> });\n});\n</code></pre>\n<h3><strong><code>act</code></strong></h3>\n<p>React 的更新是非同步的，<code>act</code> 可以<strong>確保所有相關的狀態更新、重繪和副作用在測試執行之前完成</strong>，讓斷言不會出現不一致的情況。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { render, screen } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { act } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/test-utils&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;use act to handle state updates&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counter</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">data-testid</span>=<span class=\"hljs-string\">&quot;count&quot;</span>&gt;</span>{count}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setCount((prev) =&gt; prev + 1)}&gt;Increase<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  };\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Counter</span> /&gt;</span></span>);\n\n  <span class=\"hljs-comment\">// 初始值的斷言</span>\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByTestId</span>(<span class=\"hljs-string\">&quot;count&quot;</span>).<span class=\"hljs-property\">textContent</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&quot;0&quot;</span>);\n\n  <span class=\"hljs-comment\">// 使用 act 確保狀態更新完成</span>\n  <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Increase&quot;</span>).<span class=\"hljs-title function_\">click</span>();\n  });\n\n  <span class=\"hljs-comment\">// 測試點擊按鈕後的狀態</span>\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByTestId</span>(<span class=\"hljs-string\">&quot;count&quot;</span>).<span class=\"hljs-property\">textContent</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);\n});\n</code></pre>\n<details class='spoiler'><summary>Q. 為什麼不需要 rerender，直接撰寫 expect(screen.getByTestId('count').textContent).toBe('1') 測試會過？</summary>\n<p><strong>A.</strong> act 模擬 React 的更新機制，確保所有狀態變化和相關的 DOM 更新完成後，測試才能繼續執行。</p>\n<ul>\n<li>\n<p>當狀態更新（例如 setState 或 setCount）觸發 DOM 變更時，React 需要時間計算虛擬 DOM 的變化並更新實際 DOM。</p>\n</li>\n<li>\n<p>act 會等待這些操作完成後，讓測試斷言可以直接驗證最新的 DOM 狀態。</p>\n</li>\n</ul>\n<p>在範例中，按鈕點擊觸發 setCount，React 重新渲染了 Counter 組件，<code>screen.getByTestId('count')</code> 將自動返回更新後的內容，因為 DOM 已經在 act 的控制下完成了更新。</p>\n</details>\n<h3><strong><code>waitFor</code></strong></h3>\n<p>用於等待非同步操作或渲染的完成。它會反覆執行傳入的回呼函數，直到回調內的條件滿足或超時，<strong>適合測試需等待的元素渲染或狀態改變</strong>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;wait for async updates&quot;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Component</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [text, setText] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&quot;Loading...&quot;</span>);\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">setText</span>(<span class=\"hljs-string\">&quot;Loaded&quot;</span>), <span class=\"hljs-number\">1000</span>);\n    }, []);\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{text}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  };\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> /&gt;</span></span>);\n\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">waitFor</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Loaded&quot;</span>)).<span class=\"hljs-title function_\">toBeInTheDocument</span>());\n});\n</code></pre>\n<h2 id=\"其他常用套件\" title=\"其他常用套件\"><a href=\"#其他常用套件\">其他常用套件</a></h2>\n<h3><a  href=\"https://github.com/testing-library/jest-dom\" target=\"_blank\" rel=\"noreferrer noopener\">jest-dom</a></h3>\n<p>為一個擴展 Jest matchers 的套件，提供許多的 custom matchers，使得測試斷言更加直觀和易讀，例如：<code>toBeInTheDocument</code>、<code>toBeDisabled</code>、<code>toHaveClass</code>。</p>\n<blockquote>\n<p>相關的 API @ <a  href=\"https://github.com/testing-library/jest-dom?tab=readme-ov-file#custom-matchers\" target=\"_blank\" rel=\"noreferrer noopener\">Custom matchers</a></p>\n</blockquote>\n<blockquote>\n<p>**補充：**雖然名字中有 jest，但不一定需要安裝 Jest，只需要引入 <code>@testing-library/jest-dom</code>，就可以使用它提供的 custom matchers。</p>\n</blockquote>\n<p><strong>安裝套件</strong></p>\n<pre class=\"hljs\"><code>npm install -D <span class=\"hljs-meta\">@testing</span>-library/jest-dom\n</code></pre>\n<p><strong>更新設定檔案</strong></p>\n<ol>\n<li>新增 <code>vitest-setup.ts</code> 檔案，並加入至 <code>vitest.config.ts</code> 的設定中：</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// vitest-setup.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;@testing-library/jest-dom/vitest&quot;</span>;\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { defineConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest/config&#x27;</span>\n<span class=\"hljs-keyword\">import</span> react <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@vitejs/plugin-react&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>({\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-title function_\">react</span>()],\n  <span class=\"hljs-attr\">test</span>: {\n    <span class=\"hljs-attr\">environment</span>: <span class=\"hljs-string\">&#x27;jsdom&#x27;</span>,\n    <span class=\"hljs-attr\">setupFiles</span>: [<span class=\"hljs-string\">&#x27;./vitest-setup.ts&#x27;</span>], <span class=\"hljs-comment\">// 加入剛剛新增的檔案</span>\n  },\n</code></pre>\n<blockquote>\n<p><strong>補充：</strong> 如果省略這步驟一，那撰寫測試時需要每次都手動 import <code>'@testing-library/jest-dom'</code> 套件。</p>\n</blockquote>\n<ol start=\"2\">\n<li>更新 <code>tsconfig.json</code></li>\n</ol>\n<pre class=\"hljs\"><code> <span class=\"hljs-comment\">// tsconfig.json</span>\n  <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: {\n    ...\n    <span class=\"hljs-string\">&quot;types&quot;</span>: [<span class=\"hljs-string\">&quot;vitest/globals&quot;</span>, <span class=\"hljs-string\">&quot;@testing-library/jest-dom&quot;</span>] <span class=\"hljs-comment\">// 新增此段</span>\n  },\n  <span class=\"hljs-string\">&quot;include&quot;</span>: [\n    ...\n    <span class=\"hljs-string\">&quot;./vitest.setup.ts&quot;</span> <span class=\"hljs-comment\">// 新增此段</span>\n  ],\n</code></pre>\n<p><strong>範例使用</strong></p>\n<pre class=\"hljs\"><code><span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Visible Details Example&quot;</span>)).<span class=\"hljs-title function_\">toBeVisible</span>();\n</code></pre>\n<h3><a  href=\"https://github.com/testing-library/user-event\" target=\"_blank\" rel=\"noreferrer noopener\">user-event</a></h3>\n<p>提供模擬使用者事件，對比內建的 <code>fireEvent</code> 方法，更貼近真實使用者的操作行為。</p>\n<blockquote>\n<p>相關 API @ <a  href=\"https://testing-library.com/docs/user-event/v13/#api\" target=\"_blank\" rel=\"noreferrer noopener\">user-event API</a></p>\n</blockquote>\n<p><strong>安裝套件</strong></p>\n<pre class=\"hljs\"><code>npm install -D <span class=\"hljs-meta\">@testing</span>-library/user-event\n</code></pre>\n<p><strong>範例使用</strong></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// v13 寫法</span>\n<span class=\"hljs-keyword\">import</span> { render, screen } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> userEvent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/user-event&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;@testing-library/jest-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">MyComponent</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./MyComponent&quot;</span>;\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;renders MyComponent and interacts with it&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> /&gt;</span></span>);\n  <span class=\"hljs-keyword\">const</span> input = screen.<span class=\"hljs-title function_\">getByLabelText</span>(<span class=\"hljs-string\">&quot;Username&quot;</span>);\n  <span class=\"hljs-comment\">// 模擬使用者輸入</span>\n  userEvent.<span class=\"hljs-title function_\">type</span>(input, <span class=\"hljs-string\">&quot;testuser&quot;</span>);\n  <span class=\"hljs-title function_\">expect</span>(input).<span class=\"hljs-title function_\">toHaveValue</span>(<span class=\"hljs-string\">&quot;testuser&quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> button = screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Submit&quot;</span>);\n  <span class=\"hljs-comment\">// 模擬使用者點擊</span>\n  userEvent.<span class=\"hljs-title function_\">click</span>(button);\n  <span class=\"hljs-title function_\">expect</span>(screen.<span class=\"hljs-title function_\">getByText</span>(<span class=\"hljs-string\">&quot;Submitted&quot;</span>)).<span class=\"hljs-title function_\">toBeInTheDocument</span>();\n});\n</code></pre>\n<ul>\n<li>v14 推薦寫法：渲染元件之前，調用 <code>userEvent.setup()</code></li>\n</ul>\n<blockquote>\n<p><strong>補充：</strong> v14 兼容 v13 寫法，但這主要是為了從 v13 過渡到 v14 提供便利，以及用於簡單測試。</p>\n</blockquote>\n<blockquote>\n<p><strong>補充：</strong> 避免在 <code>before</code>/<code>after</code> hook 使用任何 <code>userEvent</code> 函數，可參考 <a  href=\"https://kentcdodds.com/blog/avoid-nesting-when-youre-testing\" target=\"_blank\" rel=\"noreferrer noopener\">“Avoid Nesting When You’re Testing”</a>。</p>\n</blockquote>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// v14 推薦寫法 - inlining</span>\n<span class=\"hljs-keyword\">import</span> userEvent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/user-event&#x27;</span>\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;trigger some awesome feature when clicking the button&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> user = userEvent.<span class=\"hljs-title function_\">setup</span>()\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> /&gt;</span></span>)\n\n  <span class=\"hljs-keyword\">await</span> user.<span class=\"hljs-title function_\">click</span>(screen.<span class=\"hljs-title function_\">getByRole</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-regexp\">/click me!/i</span> }))\n  ...\n})\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// v14 推薦寫法 - setup function</span>\n<span class=\"hljs-keyword\">import</span> userEvent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/user-event&#x27;</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\">jsx</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">user</span>: userEvent.<span class=\"hljs-title function_\">setup</span>(),\n    ...<span class=\"hljs-title function_\">render</span>(jsx),\n  }\n}\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;render with a setup function&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> {user} = <span class=\"hljs-title function_\">setup</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> /&gt;</span></span>)\n  ...\n})\n</code></pre>\n<p><strong><code>user-event</code></strong> v.s <strong><code>fireEvent</code></strong></p>\n<table>\n<thead>\n<tr>\n<th>比較項目</th>\n<th><code>fireEvent</code></th>\n<th><code>user-event</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>模擬範圍</strong></td>\n<td>單一 DOM 事件（如 click、input、keydown）</td>\n<td>完整使用者互動過程（如按鍵輸入、滑鼠點擊、表單填寫等）</td>\n</tr>\n<tr>\n<td><strong>事件觸發數量</strong></td>\n<td>一次觸發單一事件</td>\n<td>一次模擬多個相關事件（如 mousedown、focus、mouseup、click）</td>\n</tr>\n<tr>\n<td><strong>檢查與限制</strong></td>\n<td>不檢查目標元素的狀態，可強制觸發事件（即使元素不可見或被禁用）</td>\n<td>檢查目標元素是否可見、可互動（如隱藏元素不能點擊、禁用元素不能輸入）</td>\n</tr>\n<tr>\n<td><strong>自動處理</strong></td>\n<td>必須手動處理互動過程中的細節（如 focus、值變更 change、失焦 blur）</td>\n<td>自動處理互動過程中的細節，模擬瀏覽器行為</td>\n</tr>\n<tr>\n<td><strong>適合使用情境</strong></td>\n<td>- 測試特定的低階 DOM 事件<br>- <code>user-event</code> 尚未實現的特殊場景</td>\n<td>測試真實的使用者互動，特別是多步驟操作（如表單填寫、拖曳等）</td>\n</tr>\n<tr>\n<td><strong>使用難度</strong></td>\n<td>需要手動撰寫所有事件及細節，較為繁瑣</td>\n<td>自動模擬瀏覽器邏輯，開發者只需描述互動，使用更簡單</td>\n</tr>\n<tr>\n<td><strong>是否貼近真實互動</strong></td>\n<td>不貼近真實使用者行為，僅觸發事件本身</td>\n<td>高度貼近真實使用者互動，考慮瀏覽器行為限制</td>\n</tr>\n</tbody>\n</table>\n<p>使用 <code>fireEvent</code>：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { render, screen, fireEvent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">MyComponent</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./MyComponent&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { fireEvent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;使用 fireEvent 測試輸入&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Input</span> /&gt;</span></span>);\n  <span class=\"hljs-keyword\">const</span> input = screen.<span class=\"hljs-title function_\">getByRole</span>(<span class=\"hljs-string\">&quot;textbox&quot;</span>);\n  fireEvent.<span class=\"hljs-title function_\">focus</span>(input);\n  fireEvent.<span class=\"hljs-title function_\">change</span>(input, { <span class=\"hljs-attr\">target</span>: { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&quot;Hello&quot;</span> } });\n  fireEvent.<span class=\"hljs-title function_\">blur</span>(input);\n});\n</code></pre>\n<p>使用 <code>user-event</code>：</p>\n<p>模擬使用者點擊 input 的行為後再去做輸入。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> userEvent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/user-event&quot;</span>;\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;使用 user-event 測試輸入&quot;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> user = userEvent.<span class=\"hljs-title function_\">setup</span>();\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Input</span> /&gt;</span></span>);\n  <span class=\"hljs-keyword\">const</span> input = screen.<span class=\"hljs-title function_\">getByRole</span>(<span class=\"hljs-string\">&quot;textbox&quot;</span>);\n  <span class=\"hljs-keyword\">await</span> user.<span class=\"hljs-title function_\">type</span>(input, <span class=\"hljs-string\">&quot;Hello&quot;</span>);\n});\n</code></pre>\n<h2 id=\"<strong>參考資料</strong>\" title=\"<strong>參考資料</strong>\"><a href=\"#<strong>參考資料</strong>\"><strong>參考資料</strong></a></h2>\n<ul>\n<li><a  href=\"https://testing-library.com/\" target=\"_blank\" rel=\"noreferrer noopener\">Testing Library</a></li>\n<li><a  href=\"https://www.youtube.com/watch?v=FDEf3iWEgFI\" target=\"_blank\" rel=\"noreferrer noopener\">Fast Unit Testing With Vitest</a></li>\n<li><a  href=\"https://ithelp.ithome.com.tw/users/20119062/ironman/5554\" target=\"_blank\" rel=\"noreferrer noopener\">「你知道這是什麼嗎？」小白也能輕鬆瞭解的 Vue3 單元測試！Feat. Vitest + Vue Test Utils</a></li>\n</ul>\n","toc":{"title":"Vitest - DOM 測試","subtitles":["Setup","原則","常用 API","其他常用套件","參考資料"]},"wordCount":2225}