{"info":{"title":"[Note] Vue (part 2) - Computed Properties & Watchers","fileName":"vue-computed-watchers","description":"Vue 的學習筆記 part 2","createdAt":"2024-12-15T00:00:00.000Z","updatedAt":"2024-12-15T00:00:00.000Z","tags":["Vue"]},"content":"<h1 id=\"[Note] Vue (part2) - Computed Properties &amp; Watchers\" title=\"[Note] Vue (part2) - Computed Properties &amp; Watchers\">[Note] Vue (part2) - Computed Properties &amp; Watchers</h1>\n<h2 id=\"Computed Properties 計算屬性\" title=\"Computed Properties 計算屬性\"><a href=\"#Computed Properties 計算屬性\">Computed Properties 計算屬性</a></h2>\n<ul>\n<li>處理複雜邏輯</li>\n<li>計算屬性的 getter 函數是沒有副作用(side effect)的\n<blockquote>\n<p><strong>注意 :</strong> 這裡是屬性，不是函式，不需要 <code>()</code></p>\n</blockquote>\n</li>\n<li>有緩存機制，只觀察他所觀察的屬性，其屬性有變化才會執行對應的 func</li>\n<li>效能比 <code>method</code> 好</li>\n<li><code>computed</code> 屬性中的 <code>function</code> 無法使用參數，要使用參數改用 <code>method</code></li>\n</ul>\n<h3>Basic Example</h3>\n<ul>\n<li>聲明了一個計算屬性 <code>reversedMessage</code></li>\n<li>提供的函數將用作 property <code>vm.reversedMessage</code> 的</li>\n</ul>\n<pre class=\"hljs\"><code>&lt;div id=&quot;example&quot;&gt;\n  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;\n  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> vm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#example&#x27;</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>\n  },\n  <span class=\"hljs-attr\">computed</span>: {\n    <span class=\"hljs-comment\">// a computed getter</span>\n    <span class=\"hljs-attr\">reversedMessage</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// `this` points to the vm instance</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n    }\n  }\n})\n</code></pre>\n<p>Vue 知道 <code>vm.reversedMessage</code> 依賴於 <code>vm.message</code>，因此當 <code>vm.message</code> 發生改變時，所有依賴 <code>vm.reversedMessage</code> 的綁定也會更新。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(vm.<span class=\"hljs-property\">reversedMessage</span>) <span class=\"hljs-comment\">// =&gt; &#x27;olleH&#x27;</span>\nvm.<span class=\"hljs-property\">message</span> = <span class=\"hljs-string\">&#x27;Goodbye&#x27;</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(vm.<span class=\"hljs-property\">reversedMessage</span>) <span class=\"hljs-comment\">// =&gt; &#x27;eybdooG&#x27;</span>\n</code></pre>\n<h3>Computed Caching vs Methods 計算屬性緩存 vs 方法</h3>\n<pre class=\"hljs\"><code>&lt;!-- 寫法一：屬性 --&gt;\n&lt;p&gt;Reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;\n\n&lt;script&gt;\n// 在组件中\n  computed: {\n    reversedMessage: function () {\n      return this.message.split('').reverse().join('')\n    }\n  }\n&lt;/script&gt;\n\n\n&lt;!-- 寫法二：方法 --&gt;\n&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;\n\n&lt;script&gt;\n// 在组件中\n    methods: {\n      reversedMessage: function () {\n        return this.message.split('').reverse().join('')\n      }\n    }\n&lt;/script&gt;\n</code></pre>\n<h4>相同：</h4>\n<ul>\n<li>可以將同一函數定義為一個方法而不是一個計算屬性。兩種方式的最終結果確實是完全相同的</li>\n</ul>\n<h4>相異：</h4>\n<ul>\n<li><strong>計算屬性是基於它們的響應式依賴進行緩存的</strong>。只在相關響應式依賴發生改變時它們才會重新求值\n<blockquote>\n<p><strong>Computed:</strong> 只要 message 還沒有發生改變，多次訪問 reversedMessage 計算屬性會立即返回之前的計算結果，而不必再次執行函數。</p>\n<p><strong>Methods:</strong> 每當觸發重新渲染時，調用方法將總會再次執行函數。</p>\n</blockquote>\n</li>\n</ul>\n<h4>Why：</h4>\n<p>假設我們有一個性能開銷比較大的計算屬性 A，它需要遍歷一個巨大的數組並做大量的計算。然後我們可能有其他的計算屬性依賴於 A。如果沒有緩存，我們將不可避免的多次執行 A 的 getter！</p>\n<h4>注意：</h4>\n<ul>\n<li>資料沒響應式依賴又要時常更新的，勿放 Computed</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 計算屬性將不再更新，因為Date.now()不是響應式依賴：</span>\n<span class=\"hljs-attr\">computed</span>: {\n  <span class=\"hljs-attr\">now</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()\n  }\n}\n</code></pre>\n<ul>\n<li>不希望有緩存，請用方法來替代</li>\n</ul>\n<h3>Computed vs Watched Property 計算屬性 vs 偵聽屬性</h3>\n<p><strong>偵聽屬性 :</strong> 觀察和響應 Vue 實例上的數據變動</p>\n<blockquote>\n<p><strong>[ 注意 ]：</strong> 但如果有一些數據需要隨著其它數據變動而變動時，很容易濫用<code>watch</code> &gt;<strong>[ 解法 ]：</strong> 使用計算屬性而不是命令式的 watch callback</p>\n</blockquote>\n<pre class=\"hljs\"><code>&lt;div id=&quot;demo&quot;&gt;{{ fullName }}&lt;/div&gt;\n</code></pre>\n<pre class=\"hljs\"><code> <span class=\"hljs-comment\">// 偵聽屬性</span>\n <span class=\"hljs-comment\">//是命令式且重複的</span>\n\n<span class=\"hljs-keyword\">let</span> vm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#demo&#x27;</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&#x27;Foo&#x27;</span>,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">&#x27;Bar&#x27;</span>,\n    <span class=\"hljs-attr\">fullName</span>: <span class=\"hljs-string\">&#x27;Foo Bar&#x27;</span>\n  },\n  <span class=\"hljs-attr\">watch</span>: {\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fullName</span> = val + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span>\n    },\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fullName</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + val\n    }\n  }\n})\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 計算屬性</span>\n<span class=\"hljs-comment\">// better</span>\n<span class=\"hljs-keyword\">let</span> vm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#demo&#x27;</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&#x27;Foo&#x27;</span>,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">&#x27;Bar&#x27;</span>\n  },\n  <span class=\"hljs-attr\">computed</span>: {\n    <span class=\"hljs-attr\">fullName</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span>\n    }\n  }\n})\n</code></pre>\n<h3>Computed Setter 計算屬性的 setter</h3>\n<p>計算屬性默認只有 getter，不過在需要時你也可以提供一個 setter:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">computed</span>: {\n  <span class=\"hljs-attr\">fullName</span>: { <span class=\"hljs-comment\">// object 形式</span>\n    <span class=\"hljs-comment\">// getter</span>\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span>\n    },\n    <span class=\"hljs-comment\">// setter</span>\n    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newValue</span>) {\n      <span class=\"hljs-keyword\">var</span> names = newValue.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>)\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> = names[<span class=\"hljs-number\">0</span>]\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span> = names[names.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>]\n    }\n  }\n}\n</code></pre>\n<p>現在再運行 <code>vm.fullName = 'John Doe'</code> 時，setter 會被調用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也會相應地被更新。</p>\n<h2 id=\"Watchers\" title=\"Watchers\"><a href=\"#Watchers\">Watchers</a></h2>\n<ul>\n<li>用於數據變化時執行異步（ex 打 API）或開銷較大的操作</li>\n</ul>\n<pre class=\"hljs\"><code>&lt;div id=&quot;watch-example&quot;&gt;\n  &lt;p&gt;\n    Ask a yes/no question:\n    &lt;input v-model=&quot;question&quot;&gt;\n  &lt;/p&gt;\n  &lt;p&gt;{{ answer }}&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<pre class=\"hljs\"><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 `question` 發生改變，這個函數就會運行\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    // `_.debounce` 是一個通過 Lodash 限制操作頻率的函數。\n\n    // 在這個例子中，我們希望限制訪問 yesno.wtf/api 的頻率\n    // AJAX 請求直到用户輸入完畢才會發出。\n\n    // `_.debounce` 函數 (及其近親 `_.throttle`) 的知識，\n    // 請參考：https://lodash.com/docs#debounce\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<p>使用 watch 選項允許我們執行異步操作(訪問一個 API)，限制我們執行該操作的頻率，並在我們得到最終結果前，設置中間狀態。這些都是計算屬性無法做到的。</p>\n<p>除了 <code>watch</code> 之外，還可以使用命令式的 <a  href=\"https://cn.vuejs.org/v2/api/#vm-watch\" target=\"_blank\" rel=\"noreferrer noopener\">vm.$watch API</a>。</p>\n","toc":{"title":"[Note] Vue (part2) - Computed Properties &amp; Watchers","subtitles":["Computed Properties 計算屬性","Watchers"]},"wordCount":990}