window.__NUXT__=(function(a,b,c){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1765978925",layout:"default",error:a,serverRendered:true,routePath:"\u002Fdev\u002FJavaScript\u002Fjs-this",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}},globalRefs:{},ssrRefs:{"articleMatter-JavaScript-js-this":{info:{title:b,fileName:"js-this",description:"JavaScript 愛恨交織的 this",createdAt:c,updatedAt:c,tags:["JavaScript","event handling"]},content:"\u003Ch6\u003Etags: \u003Ccode\u003EJavaScript\u003C\u002Fcode\u003E \u003Ccode\u003Efront-end\u003C\u002Fcode\u003E \u003Ccode\u003Ethis\u003C\u002Fcode\u003E\u003C\u002Fh6\u003E\n\u003Ch1 id=\"JavaScript - This\" title=\"JavaScript - This\"\u003EJavaScript - This\u003C\u002Fh1\u003E\n\u003Ch2 id=\"this 與前後文本 (context) 綁定的基本四大原則\" title=\"this 與前後文本 (context) 綁定的基本四大原則\"\u003E\u003Ca href=\"#this 與前後文本 (context) 綁定的基本四大原則\"\u003Ethis 與前後文本 (context) 綁定的基本四大原則\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E預設綁定 (Default Binding)\u003C\u002Fli\u003E\n\u003Cli\u003E隱含式綁定 (Implicit Binding)\u003C\u002Fli\u003E\n\u003Cli\u003E顯式綁定 (Explicit Binding)\u003C\u002Fli\u003E\n\u003Cli\u003E「new」關鍵字綁定\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E\u003Cstrong\u003E1. 預設綁定 (Default Binding)\u003C\u002Fstrong\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E意即不屬於任何物件的方法、沒有使用 bind、call、apply 或 new，就套用預設綁定，此時 this 的值就是預設值全域物件，在瀏覽器環境底下是 window。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E a = \u003Cspan class=\"hljs-number\"\u003E123\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ewindow\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E){\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F this === window\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n}\n\n\u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E(); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 123\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E同樣的情況，若是加上 “use strict” 宣告成嚴格模式後，原本預設將 this 綁定至全域物件的行爲，會轉變成 undefined，因為在 ES5 的嚴格模式下，會禁止 this 自動指定為全域物件。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E a = \u003Cspan class=\"hljs-number\"\u003E123\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ewindow\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E){\n  \u003Cspan class=\"hljs-string\"\u003E&quot;use strict&quot;\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F this === undefined\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n}\n\n\u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E(); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F TypeError: Cannot read property &#x27;a&#x27; of undefined\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003E\u003Cstrong\u003E2. 隱含式綁定 (Implicit Binding)\u003C\u002Fstrong\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E即使 function 被宣告的地方是在 global scope 中，只要它成為某個物件的參考屬性 (reference property)，在執行的階段 this 就會被綁定至該物件。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efunc\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E obj = {\n  \u003Cspan class=\"hljs-attr\"\u003Ea\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Efoo\u003C\u002Fspan\u003E: func\n};\n\n\u003Cspan class=\"hljs-title function_\"\u003Efunc\u003C\u002Fspan\u003E();       \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F undefined\u003C\u002Fspan\u003E\nobj.\u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E();    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E根據 「預設綁定」的原則，直接呼叫 func() 的情況下，此時的 this.a 實際上會指向 window.a，所以結果是 undefined。\u003C\u002Fp\u003E\n\u003Cp\u003E在 obj 物件中，將 foo 這個屬性指到 func() 的時候，再透過 obj 來呼叫 obj.foo() 的時候，雖然實際上仍是 func() 被呼叫， 但此時的 this 就會指向至 obj 這個 owner 的物件上，於是此時的 this.a 就會是 obj.a 也就是 2 。\u003C\u002Fp\u003E\n\u003Cp\u003E那麼此時，我們宣告另一個變數 func2 指向 obj.foo，猜猜看呼叫 func2() 的結果為何呢？\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efunc\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E obj = {\n  \u003Cspan class=\"hljs-attr\"\u003Ea\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Efoo\u003C\u002Fspan\u003E: func\n};\n\nobj.\u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E();  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E func2 = obj.\u003Cspan class=\"hljs-property\"\u003Efoo\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-title function_\"\u003Efunc2\u003C\u002Fspan\u003E();    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ??\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E答案是 undefined\u003C\u002Fp\u003E\n\u003Cp\u003E當我們宣告 var func2 = obj.foo; 的時候，實際上 func2 就是 window.func2，而你在執行 func2() 的時候，等同於執行 window.func2()，那麼此時的 this 就會是 window。\u003C\u002Fp\u003E\n\u003Cp\u003E決定 this 的關鍵\u003Cstrong\u003E不在於它屬於哪個物件，而是在於 function「呼叫的時機點」\u003C\u002Fstrong\u003E，當你透過物件呼叫某個方法 (method) 的時候，此時 this 就是那個物件 (owner object)。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Cstrong\u003E3. 顯式綁定 (Explicit Binding)。\u003C\u002Fstrong\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E透過 bind() \u002F call() \u002F apply() 這類直接指定 this 的 function 都可被歸類至顯式綁定的類型。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efunc\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E obj = {\n  \u003Cspan class=\"hljs-attr\"\u003Ea\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\n};\n\n\u003Cspan class=\"hljs-title function_\"\u003Efunc\u003C\u002Fspan\u003E();             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F undefined\u003C\u002Fspan\u003E\nfunc.\u003Cspan class=\"hljs-title function_\"\u003Ecall\u003C\u002Fspan\u003E(obj);     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch5\u003E「隱含式綁定」與「顯式綁定」衝突時，此時 this 會以「顯式綁定」為主\u003C\u002Fh5\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efunc\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E obj1 = { \u003Cspan class=\"hljs-attr\"\u003Ea\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-attr\"\u003Efoo\u003C\u002Fspan\u003E: func };\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E obj2 = { \u003Cspan class=\"hljs-attr\"\u003Ea\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-attr\"\u003Efoo\u003C\u002Fspan\u003E: func };\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 隱含式綁定\u003C\u002Fspan\u003E\nobj1.\u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E();  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2\u003C\u002Fspan\u003E\nobj2.\u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E();  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 顯式綁定\u003C\u002Fspan\u003E\nobj1.\u003Cspan class=\"hljs-property\"\u003Efoo\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Ecall\u003C\u002Fspan\u003E( obj2 );  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3\u003C\u002Fspan\u003E\nobj2.\u003Cspan class=\"hljs-property\"\u003Efoo\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Ecall\u003C\u002Fspan\u003E( obj1 );  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003E\u003Cstrong\u003E4. 「new」關鍵字綁定\u003C\u002Fstrong\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003Efunction 前面帶有 new 被呼叫時，會發生：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E產生一個新的物件 (物件被建構出來)\u003C\u002Fli\u003E\n\u003Cli\u003Ethis 會指向 new 出來的物件。\u003C\u002Fli\u003E\n\u003Cli\u003E除非這個 function 指定回傳 (return) 了它自己的替代物件，否則這個透過 new 產生的物件會被自動回傳。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E = a;\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E obj = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Efoo\u003C\u002Fspan\u003E( \u003Cspan class=\"hljs-number\"\u003E123\u003C\u002Fspan\u003E );\n\u003Cspan class=\"hljs-variable language_\"\u003Econsole\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Elog\u003C\u002Fspan\u003E( obj.\u003Cspan class=\"hljs-property\"\u003Ea\u003C\u002Fspan\u003E );      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 123\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"總結\" title=\"總結\"\u003E\u003Ca href=\"#總結\"\u003E總結\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E判斷順序：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Enew 綁定\u003C\u002Fli\u003E\n\u003Cli\u003E顯示綁定\u003C\u002Fli\u003E\n\u003Cli\u003E隱含式綁定\u003C\u002Fli\u003E\n\u003Cli\u003E預設綁定\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E決定 this 是誰的關鍵：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Ethis 是 function 執行時所屬的物件，this 是在執行時期做綁定，其值和函式在哪裡被呼叫有關\u003C\u002Fli\u003E\n\u003Cli\u003Efunction 透過 call() 或 apply() 來呼叫時， this 會指向第一個參數，且會立即被執行\u003C\u002Fli\u003E\n\u003Cli\u003Efunction 透過 bind() 來指定 this\u003C\u002Fli\u003E\n\u003Cli\u003EES6 箭頭函數內建 .bind() 特性，此時 this 無法複寫。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n",toc:{title:b,subtitles:["this 與前後文本 (context) 綁定的基本四大原則","總結"]},wordCount:684}}}}(null,"JavaScript - This","2025-07-17T00:00:00.000Z"));