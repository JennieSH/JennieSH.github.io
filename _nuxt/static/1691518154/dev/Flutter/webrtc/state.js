window.__NUXT__=(function(a,b,c,d){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1691518154",layout:"default",error:a,serverRendered:true,routePath:"\u002Fdev\u002FFlutter\u002Fwebrtc",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}},globalRefs:{},ssrRefs:{"articleMatter-Flutter-webrtc":{info:{title:b,fileName:"webrtc",description:"WebRTC 不只 APP 可以使用，同樣 Web 也可以實作唷！介紹 WebRTC 與之相關的名詞和連接流程。",createdAt:c,updatedAt:c,tags:["Flutter",d]},content:"\u003Ch6\u003Etags: \u003Ccode\u003EFlutter\u003C\u002Fcode\u003E、\u003Ccode\u003EWebRTC\u003C\u002Fcode\u003E\u003C\u002Fh6\u003E\n\u003Ch1 id=\"[Note] WebRTC 與他的名詞們\" title=\"[Note] WebRTC 與他的名詞們\"\u003E[Note] WebRTC 與他的名詞們\u003C\u002Fh1\u003E\n\u003Ch2 id=\"前言\" title=\"前言\"\u003E\u003Ca href=\"#前言\"\u003E前言\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E推薦 \u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=FExZvpVvYxA\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EWebRTC Crash Course\u003C\u002Fa\u003E 這部影片，把 WebRTC 會出現的名詞解釋滿清楚的，雖然後面 demo 是 web 的，但不影響概念理解。\u003C\u002Fp\u003E\n\u003Cp\u003E另外一部是 2013 Google I\u002FO 的 \u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=p2HzZkd2A40&amp;t=1272s\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EReal-time communication with WebRTC\u003C\u002Fa\u003E 也滿推的，時間有點久遠，但觀念是共通不變的，筆記中有些圖也是參考這部影片畫的。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E註: 文章內大部分圖片來源自 \u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=FExZvpVvYxA\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EWebRTC Crash Course\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"WebRTC\" title=\"WebRTC\"\u003E\u003Ca href=\"#WebRTC\"\u003EWebRTC\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003EWebRTC（Web Real-Time Communication）是指通過 API 建立點對點的連線，並可交換彼此的語音、影像和數據通信的技術，應用於視訊會議、直播和即時通訊。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E即時\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E點對點\u003C\u002Fstrong\u003E - 提高傳送效率和低延遲(因為不用透過 server 在中間溝通)\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E多平台\u003C\u002Fstrong\u003E - Browsers、Mobile\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Cdetails class='spoiler'\u003E\u003Csummary\u003E延伸問題：WebSockets v.s. WebRTC ？\u003C\u002Fsummary\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FrydC0YIrh.png\" alt=\"WebSockets v.s. WebRTC\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Ch4\u003EWebSockets\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E透過 server 實現即時溝通，資料會通過 server 傳遞給對方\u003C\u002Fli\u003E\n\u003Cli\u003E因透過 server 傳遞資料，會間接增加些許延遲時間(特別是影片和音源類型特別有感）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003EWebRTC\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E透過 browsers\u002Fdevices 實現點對點即時溝通，資料可以直接傳遞給對方\u003C\u002Fli\u003E\n\u003Cli\u003E使用 \u003Ca  href=\"https:\u002F\u002Fnordvpn.com\u002Fzh-tw\u002Fblog\u002Ftcp-udp-bijiao\u002F\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EUDP\u003C\u002Fa\u003E 傳輸協定，速度較快，\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003EQ1. \u003Ccode\u003EWebSockets\u003C\u002Fcode\u003E 和 \u003Ccode\u003EWebRTC\u003C\u002Fcode\u003E 可以同時使用嗎？\u003C\u002Fh4\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E可以，這兩者其實是互補的技術，因為 WebRTC 有一些局限性：\u003Cbr\u003E\u003Cbr \u002F\u003E\n(1) WebRTC 使用 UDP 傳輸，但 \u003Cstrong\u003EUDP 本身是一種不可靠的協議，資料傳輸過程中可能會丟失或損壞\u003C\u002Fstrong\u003E，所以通常不會用來傳輸重要資料，如：重要文件，因為只要丟失幾個 byte，檔案就直接損壞了。然而，對於傳輸影片或音訊等媒體資料，一些丟失（掉幀）並不會對觀看或聆聽體驗產生明顯影響，因此可以接受。\u003Cbr\u003E\u003Cbr \u002F\u003E\n(2) WebRTC 僅提供點對點通訊功能，無法自行建立連接，因此需要進行信令（Signaling）來交換連接資訊，以得知要與誰建立連接\u003Cbr\u002F\u003E\u003Cbr \u002F\u003E\nWebSockets 可以作為 Signaling Server 的角色，解決以上兩個限制。\u003Cbr \u002F\u003E\n第一， WebSockets 使用 TCP 傳輸，能確保信令資料（如 SDP）能夠準確、完整地傳送到對等方。\u003Cbr \u002F\u003E\n第二，提供了信令機制，解決了 WebRTC 無法自行建立連接的問題。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003C\u002Fdetails\u003E\n\u003Ch2 id=\"Peer-To-Peer Connection (P2P)\" title=\"Peer-To-Peer Connection (P2P)\"\u003E\u003Ca href=\"#Peer-To-Peer Connection (P2P)\"\u003EPeer-To-Peer Connection (P2P)\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FS1bsx5wN2.png\" alt=\"P2P\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EP2P（Peer-to-Peer）是指直接將兩個或多個計算機連接起來進行數據交換和共享，而\u003Cstrong\u003E不需要通過中央服務器進行中轉\u003C\u002Fstrong\u003E。在 P2P 模式下，每個計算機都可以充當客戶端和服務器。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E分散式架構\u003C\u002Fstrong\u003E：通過多個計算機之間的直接連接進行數據交換和共享，有效減輕服務器的負擔\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E高效性\u003C\u002Fstrong\u003E：利用多個計算機的資源進行數據傳輸和處理，可以提高數據傳輸的速度和效率\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E可靠性\u003C\u002Fstrong\u003E：由於數據通過多個節點進行傳輸，因此即使某些節點失敗或斷開連接，也不會對整個系統造成影響\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"NAT\" title=\"NAT\"\u003E\u003Ca href=\"#NAT\"\u003ENAT\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003ENAT（Network Address Translation）是一種常見的網絡協議，\u003Cstrong\u003E將私有網絡中的 IP 地址轉換為公共網絡中的 IP 地址\u003C\u002Fstrong\u003E，實現兩個網絡之間的通訊。\u003C\u002Fp\u003E\n\u003Cp\u003ENAT 協議通常由路由器、防火墻等網絡設備實現，它可以將多個設備的內部私有 IP 地址映射到一個公共 IP 地址上，從而實現多個設備通過一個公共 IP 地址訪問互聯網。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FS1zxXqvEn.png\" alt=\"\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FB1jMBqwVn.png\" alt=\"\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E優點：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E減少公共 IP 地址的使用 (解決 IPv4 位址不足)\u003C\u002Fli\u003E\n\u003Cli\u003E提高網絡的安全性\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺點：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E影響對等連接\u003C\u002Fli\u003E\n\u003Cli\u003E影響網絡性能\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3\u003ENAT Translations Method\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003EOne to One NAT (Full- cone NAT)\u003C\u002Fli\u003E\n\u003Cli\u003EAddress restricted NAT\u003C\u002Fli\u003E\n\u003Cli\u003EPort reststricted NAT\u003C\u002Fli\u003E\n\u003Cli\u003ESymmetric NAT\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cdiv class=\"info\"\u003E\n\u003Cp\u003E💡\u003Cstrong\u003E補充：\u003C\u002Fstrong\u003E\u003Cbr \u002F\u003E\n如果遇到 \u003Ccode\u003ESymmetric NAT\u003C\u002Fcode\u003E，會對 WebRTC 建立 P2P 連接帶來一定的難度，因為 P2P 連接需要直接通過公共 IP 地址進行通訊，需要搭配使用 TURN 服務器進行中繼，再將數據通過 TURN 服務器進行轉發。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E前三種 NAT 內部同一內部位址都對應到同一個外部位址，但 Symmetric NAT 內是每一內部位址對應到不同的外部位址。\u003Cbr \u002F\u003E\n:::\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cdetails class='spoiler'\u003E\u003Csummary\u003E延伸問題：為什麼需要 `STUN` 和 `TURN`？\u003C\u002Fsummary\u003E\n\u003Cp\u003E\u003Cstrong\u003E理想情況：\u003C\u002Fstrong\u003E\u003Cbr \u002F\u003E\nA 和 B 都有一個 Public IP，透過雲端交換彼此 IP 訊息後，直接建立 P2P 連線。\u003Cbr \u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FBJBZdNHBh.png\" alt=\"理想情況 webRTC\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E現實情況：\u003C\u002Fstrong\u003E\u003Cbr \u002F\u003E\nNAT 會分發所謂的 Privacy IP，這些 Privacy IP 無法用於建立 P2P 連接，所以需要透過 STUN + TURN 的技術，穿透 NAT 這座高牆。\u003Cbr \u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FryndYNrB3.png\" alt=\"現實情況 webRTC\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fdetails\u003E\n\u003C\u002Fdiv\u003E\n\u003Ch2 id=\"STUN 服務器\" title=\"STUN 服務器\"\u003E\u003Ca href=\"#STUN 服務器\"\u003ESTUN 服務器\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FHyeA35DN2.png\" alt=\"\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESTUN（Simple Traversal of UDP through NATs）服務器用於獲取用戶的公共 IP 地址和端口號。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E取得 public IP 地址\u003C\u002Fli\u003E\n\u003Cli\u003E對於 \u003Ccode\u003ESymmetric NAT\u003C\u002Fcode\u003E 無效\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E通過比較 STUN 服務器提供的 IP 和你自己電腦的地址，就可以判斷是否需要穿越 NAT，市面上也有一些現成的 \u003Ca  href=\"https:\u002F\u002Fgist.github.com\u002Fmondain\u002Fb0ec1cf5f60ae726202e\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ESTUN 服務器\u003C\u002Fa\u003E可以使用。\u003C\u002Fp\u003E\n\u003Ch2 id=\"TURN 服務器\" title=\"TURN 服務器\"\u003E\u003Ca href=\"#TURN 服務器\"\u003ETURN 服務器\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FSkQYCcw43.png\" alt=\"\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETURN（Traversal Using Relays around NAT）可以作為\u003Cstrong\u003E中繼站\u003C\u002Fstrong\u003E，將通信流量轉發到另一端。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EP2P 連接失敗時，提供雲端備援\u003C\u002Fli\u003E\n\u003Cli\u003E確保任何環境條件下，都可以正常連接\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E優先使用 STUN 服務器，如遇到 \u003Ccode\u003ESymmetric NAT\u003C\u002Fcode\u003E 這類型的，才會使用 TURN 服務器，因為 TURN 服務器會增加網路流量和延遲，選擇的過程會藉由 ICE 的技術來實現。\u003C\u002Fp\u003E\n\u003Ch2 id=\"ICE - 交互式連接建立\" title=\"ICE - 交互式連接建立\"\u003E\u003Ca href=\"#ICE - 交互式連接建立\"\u003EICE - 交互式連接建立\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003EICE（Interactive Connectivity Establishment）通過對 STUN 和 TURN 發出請求，收集多個 ICE Candidates，並嘗試出各種可能性，\u003Cstrong\u003E找出 P2P 連線的最佳路徑\u003C\u002Fstrong\u003E，是實現 NAT 穿越方式之一。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E收集的 ICE Candidates (addresses)\u003C\u002Fli\u003E\n\u003Cli\u003E找出最佳連接路徑\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cdiv class=\"info\"\u003E\n\u003Cp\u003E💡\u003Cstrong\u003E補充：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EICE Candidate\u003C\u002Fstrong\u003E 是建立對等連接的網路地址，包含 IP 地址和端口號，該 IP 地址可以是公共 IP、本地 IP 或中繼伺服器的地址。\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Ch2 id=\"SDP - 會話描述協議\" title=\"SDP - 會話描述協議\"\u003E\u003Ca href=\"#SDP - 會話描述協議\"\u003ESDP - 會話描述協議\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FHJrTGivNn.png\" alt=\"\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESDP 會話描述協議（Session Description Protocol）描述通訊的基本信息（IP 地址、端口號、加密通信的公鑰信息等）、影像和音頻流信息、數據通道等信息，是一份(字符串)文件。\u003C\u002Fp\u003E\n\u003Cp\u003E通過 SDP，兩端的設備，可以確定媒體流的格式、傳輸參數和連接信息等，以確保成功建立對應的多媒體通信。\u003C\u002Fp\u003E\n\u003Ch2 id=\"Signaling Server - 信令服務器\" title=\"Signaling Server - 信令服務器\"\u003E\u003Ca href=\"#Signaling Server - 信令服務器\"\u003ESignaling Server - 信令服務器\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E建立 P2P 連線前，因為客戶端彼此不知道對方，因此需要透過\u003Cstrong\u003E信令服務器（Signaling Server）進行中介\u003C\u002Fstrong\u003E，交換客戶端的會話描述協議（SDP）和 ICE Candidates 等。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ESignaling Server 可以想像就是幫兩邊 Client 傳遞兩種主要訊息：\u003Cbr \u002F\u003E\n(1) \u003Ccode\u003E連接什麼\u003C\u002Fcode\u003E 和 \u003Ccode\u003E如何連接\u003C\u002Fcode\u003E - SDP\u003Cbr \u002F\u003E\n(2) \u003Ccode\u003E使用哪條路徑連接\u003C\u002Fcode\u003E - ICE Candidates\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FrJdH1OAH3.png\" alt=\"Signaling step 1\" \u002F\u003E\u003Cbr \u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002Fr1PqkORB2.png\" alt=\"Signaling step 2\" \u002F\u003E\u003Cbr \u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhackmd.io\u002F_uploads\u002FrySaJ_RHh.png\" alt=\"Signaling step 2\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E信令服務器可以是自行搭建的伺服器或第三方開發平台，例如 Firebase 等\u003C\u002Fp\u003E\n\u003Ch2 id=\"WebRTC 連接流程\" title=\"WebRTC 連接流程\"\u003E\u003Ca href=\"#WebRTC 連接流程\"\u003EWebRTC 連接流程\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003EA 想要與 B 建立連接\u003C\u002Fli\u003E\n\u003Cli\u003EA 找出所有可能的公開連接方式\u003C\u002Fli\u003E\n\u003Cli\u003EB 找出所有可能的公開連接方式\u003C\u002Fli\u003E\n\u003Cli\u003EA 和 B 通過其他方式（e.g. WebSockets\u002FHTTP fetch）傳遞會話信息\u003C\u002Fli\u003E\n\u003Cli\u003EA 通過最優的路徑連接到 B\u003C\u002Fli\u003E\n\u003Cli\u003EA 和 B 建立 P2P 連線\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"參考資料\" title=\"參考資料\"\u003E\u003Ca href=\"#參考資料\"\u003E參考資料\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=FExZvpVvYxA\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EWebRTC Crash Course\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca  href=\"https:\u002F\u002Fzenn.dev\u002Ffaucon\u002Farticles\u002F085ab8e420b432\" target=\"_blank\" rel=\"noreferrer noopener\"\u003E【Flutter✖️WebRTC】WebRTC について学んだことのまとめ\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=IFPFNiFozdw&amp;t=58s\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EWebRTC for flutter Developer\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=p2HzZkd2A40&amp;t=1272s\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EReal-time communication with WebRTC: Google I\u002FO 2013\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca  href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=8I2axE6j204&amp;t=632s\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EHow Does WebRTC Work? | Crash Course\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca  href=\"https:\u002F\u002Fably.com\u002Ftopic\u002Fwebrtc-vs-websocket\" target=\"_blank\" rel=\"noreferrer noopener\"\u003EWebRTC vs. WebSocket: Key differences and which to use\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n",toc:{title:b,subtitles:["前言",d,"Peer-To-Peer Connection (P2P)","NAT","STUN 服務器","TURN 服務器","ICE - 交互式連接建立","SDP - 會話描述協議","Signaling Server - 信令服務器","WebRTC 連接流程","參考資料"]}}}}}(null,"[Note] WebRTC 與他的名詞們","2023-05-05T00:00:00.000Z","WebRTC"));