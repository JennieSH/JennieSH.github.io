{"info":{"title":"[Note] TypeScript - The Basic Types","fileName":"typescript-basic-types","description":"TypeScript 基本型別複習筆記。","createdAt":"2024-12-15T00:00:00.000Z","updatedAt":"2024-12-15T00:00:00.000Z","tags":["TypeScript"]},"content":"<h1 id=\"[Note] TypeScript - The Basic Types\" title=\"[Note] TypeScript - The Basic Types\">[Note] TypeScript - The Basic Types</h1>\n<h2 id=\"Why TypeScript?\" title=\"Why TypeScript?\"><a href=\"#Why TypeScript?\">Why TypeScript?</a></h2>\n<ul>\n<li>在編譯階段避免掉型別錯誤</li>\n<li>更好的語法支持 (autocompletion)</li>\n<li>可讀性、可維護性高</li>\n<li>更好開發體驗 (debugging)</li>\n</ul>\n<h2 id=\"原始資料型別 - The primitives\" title=\"原始資料型別 - The primitives\"><a href=\"#原始資料型別 - The primitives\">原始資料型別 - The primitives</a></h2>\n<h3>布林值 boolean</h3>\n<p>使用 <code>boolean</code> 定義布林值型別</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">isDone</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">false</span>;\n</code></pre>\n<div class=\"warning\">\n<p>注意：使用建構函式 Boolean 建立的物件<strong>不是</strong>布林值，<code>new Boolean()</code> 返回的是一個 Boolean 物件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.</span>\n<span class=\"hljs-comment\">// &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible.</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">createdByNewBoolean</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-number\">1</span>);\n</code></pre>\n</div>\n<h3>數值 number</h3>\n<p>使用 <code>number</code> 定義數值型別</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">decLiteral</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">6</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">hexLiteral</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0xf00d</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">binaryLiteral</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0b1010</span>; <span class=\"hljs-comment\">// 10, 二進位制表示法</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">octalLiteral</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0o744</span>; <span class=\"hljs-comment\">// 484, 八進位制表示法</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">notANumber</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-title class_\">Na</span>N; <span class=\"hljs-comment\">// Not A Number 是數值型別 ！！</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">infinityNumber</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-title class_\">Infinity</span>;\n</code></pre>\n<h3>字串 string</h3>\n<p>使用 <code>string</code> 定義字串型別</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">greet</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;\n</code></pre>\n<h3>空值 void</h3>\n<p>使用 <code>void</code> 表示沒有任何返回值的<strong>函式</strong></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-built_in\">void</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);\n}\n</code></pre>\n<div class=\"info\">\n<p><code>void</code> 用於函式，不能賦值給其他型別的變數<br />\n<br/></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// incorrect</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">u</span>: <span class=\"hljs-built_in\">void</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">num</span>: <span class=\"hljs-built_in\">number</span> = u;\n\n<span class=\"hljs-comment\">// Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span>\n</code></pre>\n</div>\n<h3>Null 和 Undefined</h3>\n<p>使用 <code>null</code> 和 <code>undefined</code> 定義變數</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">u</span>: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">n</span>: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n</code></pre>\n<div class=\"info\">\n<p><code>undefined</code> 和 <code>null</code> 是所有型別的子型別，可以賦值給 <code>number</code> 型別的變數。<br />\n<br/></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// correct</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">num</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-literal\">undefined</span>;\n</code></pre>\n</div>\n<h2 id=\"任意值 - any\" title=\"任意值 - any\"><a href=\"#任意值 - any\">任意值 - any</a></h2>\n<p>使用 <code>any</code> 表示允許賦值為任意型別</p>\n<h3>可任意改變型別</h3>\n<p>如果是一個普通型別，在賦值或宣告型別後，再改變型別是不被允許的，但如果是 any 型別，則允許被賦值為任意型別。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// TypeSceipt 不會報錯</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myFavoriteNumber</span>: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-string\">&#x27;seven&#x27;</span>;\nmyFavoriteNumber = <span class=\"hljs-number\">7</span>;\n</code></pre>\n<h3><code>any</code> 返回的內容的型別都是 <code>any</code></h3>\n<p>宣告一個變數為任意值之後，對它的任何操作，返回的內容的型別都是任意值。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// TypeSceipt 不會報錯，跟使用 js 效果是一樣</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">anyThing</span>: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(anyThing.<span class=\"hljs-property\">myName</span>);\n</code></pre>\n<h3>未宣告型別的變數，視同 <code>any</code></h3>\n<p>變數如果在宣告的時候，未指定其型別，那麼它會被識別為任意值型別。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> something; <span class=\"hljs-comment\">// 等同於 let something: any</span>\nsomething = <span class=\"hljs-string\">&#x27;seven&#x27;</span>;\nsomething = <span class=\"hljs-number\">7</span>;\n</code></pre>\n<h2 id=\"型別註解 - Type Annotation\" title=\"型別註解 - Type Annotation\"><a href=\"#型別註解 - Type Annotation\">型別註解 - Type Annotation</a></h2>\n<p>透過手動註解的方式，明確宣告資料型別，在變數、參數或屬性後面加上冒號 <code>:型別</code></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">greet</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">max</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">100</span>;\n</code></pre>\n<h2 id=\"型別推論 - Type Inference\" title=\"型別推論 - Type Inference\"><a href=\"#型別推論 - Type Inference\">型別推論 - Type Inference</a></h2>\n<p>如果沒有明確的指定型別，會依照型別推論的規則推斷出一個型別</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> myFavoriteNumber = <span class=\"hljs-string\">&#x27;seven&#x27;</span>;\n<span class=\"hljs-comment\">// 等同於 let myFavoriteNumber: string = &#x27;seven&#x27;;</span>\nmyFavoriteNumber = <span class=\"hljs-number\">7</span>;\n\n<span class=\"hljs-comment\">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span>\n</code></pre>\n<h2 id=\"聯合型別 - Union Types\" title=\"聯合型別 - Union Types\"><a href=\"#聯合型別 - Union Types\">聯合型別 - Union Types</a></h2>\n<p>聯合型別使用 <code>|</code> 分隔每個型別，表示取值可以為多種型別中的一種</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 代表 myFavoriteNumber 只能是 string 或者 number，其他型別會報錯</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myFavoriteNumber</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\nmyFavoriteNumber = <span class=\"hljs-string\">&#x27;seven&#x27;</span>;\nmyFavoriteNumber = <span class=\"hljs-number\">7</span>;\n</code></pre>\n<h3>存取聯合型別的屬性或方法</h3>\n<p>因 TypeScript 不確定一個聯合型別的變數到底是哪個型別，<strong>只能存取此聯合型別的所有型別裡共有的屬性或方法</strong>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getLength</span>(<span class=\"hljs-params\">something: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> something.<span class=\"hljs-property\">length</span>;\n}\n\n<span class=\"hljs-comment\">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span>\n<span class=\"hljs-comment\">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span>\n</code></pre>\n<p><code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有屬性，所以會報錯。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myFavoriteNumber</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\nmyFavoriteNumber = <span class=\"hljs-string\">&#x27;seven&#x27;</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myFavoriteNumber.<span class=\"hljs-property\">length</span>); <span class=\"hljs-comment\">// 5</span>\nmyFavoriteNumber = <span class=\"hljs-number\">7</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myFavoriteNumber.<span class=\"hljs-property\">length</span>); <span class=\"hljs-comment\">// 編譯時報錯</span>\n\n<span class=\"hljs-comment\">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span>\n</code></pre>\n<p>第二行的 <code>myFavoriteNumber</code> 被推斷成了 <code>string</code>，可以存取 length 屬性。</p>\n<p>第四行的 <code>myFavoriteNumber</code> 被推斷成了 <code>number</code>，<code>number</code> <code>無length</code> 屬性時就報錯了。</p>\n<h2 id=\"物件的型別 介面 - Interface\" title=\"物件的型別 介面 - Interface\"><a href=\"#物件的型別 介面 - Interface\">物件的型別 介面 - Interface</a></h2>\n<p>使用介面（Interfaces）來定義物件的型別，具體如何行動則需要由類別（classes）去實現（implement）</p>\n<ul>\n<li>介面一般首字母大寫</li>\n<li>賦值的時候，變數的形狀必須和介面的形狀保持一致</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 定義了一個介面 Person</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-comment\">// 定義了一個變數 tom，它的型別是 Person</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span>\n};\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-comment\">// 少/多 屬性皆不允許，需與 interface 一樣</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>\n};\n\n<span class=\"hljs-comment\">// index.ts(6,5): error TS2322: Type &#x27;{ name: string; }&#x27; is not assignable to type &#x27;Person&#x27;.</span>\n<span class=\"hljs-comment\">//   Property &#x27;age&#x27; is missing in type &#x27;{ name: string; }&#x27;.</span>\n</code></pre>\n<h3>可選屬性 Optional Properties</h3>\n<p>使用 <code>?</code> 表示可選屬性，但仍然不允許新增未定義的屬性。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>\n};\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span>,\n    <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span>\n};\n\n<span class=\"hljs-comment\">// examples/playground/index.ts(9,5): error TS2322: Type &#x27;{ name: string; age: number; gender: string; }&#x27; is not assignable to type &#x27;Person&#x27;.</span>\n<span class=\"hljs-comment\">// Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span>\n</code></pre>\n<h3>任意屬性 Indexable Types</h3>\n<p>如希望一個介面允許有任意的屬性，使用 <code>[propName: type]</code> 來表示任意屬性取 <code>type</code> 型別的值</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// [propName: string] 定義了任意屬性取 string 型別的值</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span>\n};\n</code></pre>\n<div class=\"warning\">\n<p>一旦<strong>定義了任意屬性</strong>，那麼<strong>確定屬性和可選屬性的型別都必須是它的型別的子集</strong>。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n    <span class=\"hljs-comment\">// 使用 [propName: string] 定義了任意屬性取 string 型別的值</span>\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span>,\n    <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span>\n};\n\n<span class=\"hljs-comment\">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span>\n<span class=\"hljs-comment\">// index.ts(7,5): error TS2322: Type &#x27;{ [x: string]: string | number; name: string; age: number; gender: string; }&#x27; is not assignable to type &#x27;Person&#x27;.</span>\n<span class=\"hljs-comment\">//   Index signatures are incompatible.</span>\n<span class=\"hljs-comment\">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span>\n<span class=\"hljs-comment\">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span>\n</code></pre>\n<p>任意屬性的值允許是 <code>string</code>，但是可選屬性 <code>age</code> 的值卻是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子屬性，所以報錯了。</p>\n<br/>\n<p>如要確定 <code>interface</code> 會存在兩個以上型別，任意屬性的型別可使用<strong>聯合型別</strong>，或是使用 <strong><code>any</code></strong>。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-comment\">// age 屬性是可選的，可能為 undefined 型別</span>\n    age?: <span class=\"hljs-built_in\">number</span>;\n    <span class=\"hljs-comment\">// strict 模式一定要加上 undefined，否則會報錯</span>\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">undefined</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span>,\n    <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span>\n};\n</code></pre>\n</div>\n<div class=\"info\">\n<p><strong>補充：</strong><br />\n<code>[propName: string]: string</code> 是指在 <code>interface</code> 內的 <code>key</code> 的型別是 <code>string</code>，TypeScript 會去約束確定屬性和可選屬性的 <code>key</code> 是 <code>string</code> 的型別，都必須是任意屬性的型別的子集。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 會報錯，age 這個 key 型別是 string，所以他會被任意屬性的型別約束</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span> ;\n}\n\n<span class=\"hljs-comment\">// Property &#x27;age&#x27; of type &#x27;number | undefined&#x27; is not assignable to string index type &#x27;string&#x27;</span>\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 不報錯，propName 型別會是 number，不會去檢查非 number 型別的 key</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span> ;\n}\n</code></pre>\n<p>key 的類型會有 number 的情境，可以參考內置對象的型別 <a  href=\"https://willh.gitbook.io/typescript-tutorial/basics/type-of-array#lei-bie-zhen-lie\" target=\"_blank\" rel=\"noreferrer noopener\"><code>IArguments</code></a>。</p>\n</div>\n<h3>唯讀屬性 readonly properties</h3>\n<p>希望物件中的一些欄位<strong>只能在建立的時候被賦值</strong>，那麼可以用 <code>readonly</code> 定義唯讀屬性</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">number</span>;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">89757</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span>\n};\n\ntom.<span class=\"hljs-property\">id</span> = <span class=\"hljs-number\">9527</span>;\n\n<span class=\"hljs-comment\">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span>\n</code></pre>\n<p>使用 <code>readonly</code> 定義的屬性 id 初始化後，又被賦值了，所以報錯了。</p>\n<div class=\"warning\">\n<p><strong>唯讀的約束存在於第一次給「物件」賦值的時候，而不是第一次給「唯讀屬性」賦值的時候</strong></p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">number</span>;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    age?: <span class=\"hljs-built_in\">number</span>;\n    [<span class=\"hljs-attr\">propName</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Person</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span>\n};\n\ntom.<span class=\"hljs-property\">id</span> = <span class=\"hljs-number\">89757</span>;\n\n<span class=\"hljs-comment\">// index.ts(8,5): error TS2322: Type &#x27;{ name: string; gender: string; }&#x27; is not assignable to type &#x27;Person&#x27;.</span>\n<span class=\"hljs-comment\">//   Property &#x27;id&#x27; is missing in type &#x27;{ name: string; gender: string; }&#x27;.</span>\n<span class=\"hljs-comment\">// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span>\n</code></pre>\n<p>有兩個 error： 1. 對 tom 進行賦值的時候，沒有給 id 賦值 2. <code>tom.id</code> 賦值的時候，由於它是只讀屬性，所以報錯了</p>\n</div>\n<h2 id=\"陣列的型別 - Array\" title=\"陣列的型別 - Array\"><a href=\"#陣列的型別 - Array\">陣列的型別 - Array</a></h2>\n<p>主要有三種表示式可以定義陣列的型別</p>\n<h3>型別 + []</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 數值型別的陣列，陣列內的值只允許是 number</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fibonacci</span>: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n</code></pre>\n<ul>\n<li>陣列內的值不允許出現其他的型別</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fibonacci</span>: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n\n<span class=\"hljs-comment\">// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span>\n</code></pre>\n<ul>\n<li>陣列的一些方法也會根據陣列在定義時約定的型別進行參數型別的限制</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fibonacci</span>: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n\n<span class=\"hljs-comment\">// push 方法只允許傳入 number 型別的參數，卻傳了個 string</span>\nfibonacci.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;8&#x27;</span>);\n\n<span class=\"hljs-comment\">// Argument of type &#x27;&quot;8&quot;&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span>\n</code></pre>\n<h3>Array&lt;型別&gt;</h3>\n<p>使用陣列泛型（Array Generic) 來表示</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fibonacci</span>: <span class=\"hljs-title class_\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n</code></pre>\n<h3>interface</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">NumberArray</span> {\n    [<span class=\"hljs-attr\">index</span>: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fibonacci</span>: <span class=\"hljs-title class_\">NumberArray</span> = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n</code></pre>\n<p><code>NumberArray</code> 表示：只要 <code>index</code> 的型別是數字時，那麼值的型別必須是數字。</p>\n<p>很少這樣寫，通常用於特殊情境，例如：類別陣列。</p>\n<h4>類別陣列</h4>\n<p>類別陣列（Array-like Object）不是陣列型別，比如 <code>arguments</code>。</p>\n<blockquote>\n<p><code>arguments</code> 為 JavaScript 的<a  href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\" target=\"_blank\" rel=\"noreferrer noopener\">內建物件</a>，它們直接在 TypeScript 中當做定義好了的型別。</p>\n</blockquote>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">args</span>: <span class=\"hljs-built_in\">number</span>[] = <span class=\"hljs-variable language_\">arguments</span>;\n}\n\n<span class=\"hljs-comment\">// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span>\n</code></pre>\n<p><code>arguments</code> 不能用普通的陣列的方式來描述，而應該用 interface，屬性可參考 <a  href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#properties\" target=\"_blank\" rel=\"noreferrer noopener\">MDN</a>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">args</span>: {\n        [<span class=\"hljs-attr\">index</span>: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">number</span>;\n        <span class=\"hljs-attr\">length</span>: <span class=\"hljs-built_in\">number</span>;\n        <span class=\"hljs-attr\">callee</span>: <span class=\"hljs-title class_\">Function</span>;\n    } = <span class=\"hljs-variable language_\">arguments</span>;\n}\n</code></pre>\n<p>我們除了約束當 <code>index</code> 的型別是數字時，值的型別必須是數字之外，也約束了它還有 <code>length</code> 和 <code>callee</code> 兩個屬性，此時就不會報錯了。</p>\n<div class=\"info\">\n<p>常用的類別陣列 TypeScript 都有介面定義，如 <code>IArguments</code>、 <code>NodeList</code>、 <code>HTMLCollection</code> 等。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// arguments 在 TypeScript 內建的介面定義為 IArguments</span>\n\n<span class=\"hljs-keyword\">interface</span> IArguments {\n    [<span class=\"hljs-attr\">index</span>: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">any</span>;\n    <span class=\"hljs-attr\">length</span>: <span class=\"hljs-built_in\">number</span>;\n    <span class=\"hljs-attr\">callee</span>: <span class=\"hljs-title class_\">Function</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">args</span>: IArguments = <span class=\"hljs-variable language_\">arguments</span>;\n}\n</code></pre>\n</div>\n<h4>any 陣列</h4>\n<p>any 陣列內可允許出現任意型別</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">list</span>: <span class=\"hljs-built_in\">any</span>[] = [<span class=\"hljs-string\">&#x27;xcatliu&#x27;</span>, <span class=\"hljs-number\">25</span>, { <span class=\"hljs-attr\">website</span>: <span class=\"hljs-string\">&#x27;http://xcatliu.com&#x27;</span> }];\n</code></pre>\n<h2 id=\"函式的型別 - Function Types\" title=\"函式的型別 - Function Types\"><a href=\"#函式的型別 - Function Types\">函式的型別 - Function Types</a></h2>\n<blockquote>\n<p><a  href=\"https://www.cnblogs.com/fundebug/p/javascript-first-class-function.html\" target=\"_blank\" rel=\"noreferrer noopener\">函式是 JavaScript 中的一等公民</a>：<br />\n它們和其他對象都一樣，可以像對待任何其他數據類型一樣對待它們，作為<strong>函數參數</strong>，可以作為<strong>函數返回值</strong>，也可以<strong>賦值給變量</strong>。</p>\n</blockquote>\n<h3>函式宣告</h3>\n<p>常見的定義函式的方式 :</p>\n<ol>\n<li>函式宣告（Function Declaration）</li>\n<li>函式表示式（Function Expression）\n<blockquote>\n<p>TypeScript 的型別定義中，<code>=&gt;</code> 用來表示函式的定義，左邊是輸入型別，需要用括號括起來，右邊是輸出型別</p>\n</blockquote>\n</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// javascript</span>\n<span class=\"hljs-comment\">// 函式宣告（Function Declaration）</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x, y</span>) {\n    <span class=\"hljs-keyword\">return</span> x + y;\n}\n\n<span class=\"hljs-comment\">// 函式表示式（Function Expression）</span>\n<span class=\"hljs-keyword\">let</span> mySum = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) {\n    <span class=\"hljs-keyword\">return</span> x + y;\n};\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// typescript</span>\n<span class=\"hljs-comment\">// 函式宣告（Function Declaration）</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> x + y;\n}\n\n<span class=\"hljs-comment\">// 函式表示式（Function Expression）</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">mySum</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> x + y;\n};\n</code></pre>\n<div class=\"info\">\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// mySum 的型別是透過賦值操作進行型別推論</span>\n<span class=\"hljs-keyword\">let</span> mySum = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> x + y;\n};\n\n<span class=\"hljs-comment\">// 手動給 mySum 新增型別</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">mySum</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> x + y;\n};\n</code></pre>\n<p>上面第二行的程式碼只對等號右側的匿名函式進行了型別定義，而等號左邊的 <strong><code>mySum</code></strong>，是透過賦值操作進行<strong>型別推論而推斷出來的</strong>。</p>\n</div>\n<ul>\n<li>輸入多餘的（或者少於要求的）參數，是不被允許的</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> x + y;\n}\n<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-comment\">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span>\n</code></pre>\n<h3>interface 定義函式型別</h3>\n<p>使用 interface 的方式來定義一個函式需要符合的形狀</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SumFunc</span> {\n    (<span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>) : <span class=\"hljs-built_in\">number</span>\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">mySum</span>: <span class=\"hljs-title class_\">SumFunc</span>  = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> x + y;\n}\n</code></pre>\n<h3>可選參數</h3>\n<ul>\n<li>\n<h4>使用 <code>?</code> 表示可選的參數</h4>\n</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y?: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">if</span>(y) <span class=\"hljs-keyword\">return</span> x+y;\n    <span class=\"hljs-keyword\">return</span> x ;\n}\n</code></pre>\n<div class=\"warning\">\n<p><strong>使用 <code>?</code> 的情境下：</strong><br />\n可選參數必須接在必需參數後面，<strong>可選參數後面不允許再出現必需參數</strong>。<br />\n<br/></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x?: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">if</span>(x) <span class=\"hljs-keyword\">return</span> x+y;\n    <span class=\"hljs-keyword\">return</span> y ;\n}\n\n<span class=\"hljs-comment\">// A required parameter cannot follow an optional parameter.</span>\n</code></pre>\n</div>\n<ul>\n<li>\n<h4>參數預設值</h4>\nTypeScript 會將添加了<strong>預設值的參數識別為可選參數</strong></li>\n</ul>\n<p><img src=\"https://i.imgur.com/2xll5gr.png\" alt=\"參數預設值\" /></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">2</span></span>): <span class=\"hljs-built_in\">number</span> {\n   <span class=\"hljs-keyword\">return</span> x+y;\n}\n\n<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 6</span>\n</code></pre>\n<div class=\"info\">\n<p><strong>使用預設值的情境下：</strong></p>\n<p><strong>不受</strong>「可選參數必須接在必需參數後面」的限制。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">10</span>, y: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> {\n   <span class=\"hljs-keyword\">return</span> x+y;\n}\n\n<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 11</span>\n<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 11</span>\n</code></pre>\n</div>\n<h3>剩餘參數</h3>\n<p>使用 <code>...rest</code> 的方式獲取函式中的剩餘參數<a  href=\"https://es6.ruanyifeng.com/#docs/function#rest%E5%BC%95%E6%95%B8\" target=\"_blank\" rel=\"noreferrer noopener\">（rest 參數）</a></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// javascript</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">array, ...items</span>) {\n    items.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>) {\n        array.<span class=\"hljs-title function_\">push</span>(item);\n    });\n}\n\n<span class=\"hljs-keyword\">let</span> a = [];\n<span class=\"hljs-title function_\">push</span>(a, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// [1, 2, 3]</span>\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// typescript</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">array: <span class=\"hljs-built_in\">number</span>[], ...items: <span class=\"hljs-built_in\">number</span>[]</span>) {\n    items.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>) {\n        array.<span class=\"hljs-title function_\">push</span>(item);\n    });\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">a</span>:<span class=\"hljs-built_in\">number</span>[] = [];\n<span class=\"hljs-title function_\">push</span>(a, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// [1, 2, 3]</span>\n</code></pre>\n<div class=\"warning\">\n<p>注意，<a  href=\"https://es6.ruanyifeng.com/#docs/function#rest-%E5%8F%82%E6%95%B0\" target=\"_blank\" rel=\"noreferrer noopener\">rest 參數</a>之後不能再有其他參數（即只能是最後一個參數），否則會報錯，同 javascript ES6 規則。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>[], ...b:<span class=\"hljs-built_in\">number</span>[], c:<span class=\"hljs-built_in\">number</span></span>) {\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-comment\">// A rest parameter must be last in a parameter list.</span>\n</code></pre>\n</div>\n<h3>過載 (Function Overloads)</h3>\n<p>過載允許一個函式接受不同數量或型別參數時，作出不同的處理</p>\n<h4>聯合型別寫法</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 聯合型別</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;number&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Number</span>(x.<span class=\"hljs-title function_\">toString</span>().<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> x.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n    }\n}\n\n<span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-string\">&#x27;abc&#x27;</span>) <span class=\"hljs-comment\">// &quot;cba&quot;</span>\n<span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-number\">123</span>) <span class=\"hljs-comment\">// 321</span>\n</code></pre>\n<p><img src=\"https://i.imgur.com/Zq0Ysby.png\" alt=\"聯合型別\" /></p>\n<p><img src=\"https://i.imgur.com/CGBsFBw.png\" alt=\"聯合型別 1\" /></p>\n<p>利用聯合型別，實現數字和字串的反轉；但其<strong>缺點</strong>為，<strong>不能夠精確的表達</strong>，輸入為數字的時候，輸出也應該為數字，輸入為字串的時候，輸出也應該為字串。</p>\n<h4>過載定義寫法</h4>\n<p>使用過載定義多個 reverse 的函式型別，前幾次都是函式定義，最後一次是函式實現。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 過載定義多個 reverse 的函式型別</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">string</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;number&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Number</span>(x.<span class=\"hljs-title function_\">toString</span>().<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> x.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n    }\n}\n</code></pre>\n<p><img src=\"https://i.imgur.com/mb3d1fw.png\" alt=\"過載\" /></p>\n<p><img src=\"https://i.imgur.com/QgRqkLN.png\" alt=\"過載1\" /><br />\n<img src=\"https://i.imgur.com/zTRooIw.png\" alt=\"過載2\" /></p>\n<div class=\"warning\">\n<p>注意，TypeScript 會<strong>優先從最前面的函式定義開始匹配</strong>，所以多個函式定義如果有包含關係，需要<strong>優先把精確的定義寫在前面</strong>。<a  href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#function-overloads\" target=\"_blank\" rel=\"noreferrer noopener\">(Function Overloads - Ordering)</a></p>\n</div>\n<h2 id=\"型別斷言 - Type Assertion\" title=\"型別斷言 - Type Assertion\"><a href=\"#型別斷言 - Type Assertion\">型別斷言 - Type Assertion</a></h2>\n<p>型別斷言可以用來手動指定一個值的型別</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 寫法一：</span>\n&lt;型別&gt;值\n\n<span class=\"hljs-comment\">// 寫法二 (React 只能使用這種)：</span>\n值 <span class=\"hljs-keyword\">as</span> 型別\n</code></pre>\n<p>形如 <code>&lt;Foo&gt;</code> 的語法在 tsx 中表示的是一個 ReactNode，在 ts 中除了表示型別斷言之外，也可能是表示一個泛型。</p>\n<p>故建議大家在使用型別斷言時，統一使用<code>值 as 型別</code>這樣的語法。</p>\n<h3>斷言應用和特性</h3>\n<ul>\n<li>聯合型別可以被斷言為其中一個型別</li>\n<li>父類可以被斷言為子類</li>\n<li>任何型別都可以被斷言為 any</li>\n<li>any 可以被斷言為任何型別</li>\n<li>要使得 A 能夠被斷言為 B，只需要 A 兼容 B 或 B 兼容 A 即可</li>\n</ul>\n<h4>將一個聯合類型斷言為其中一個類型</h4>\n<p>當 TypeScript 不確定一個聯合類型的變量到底是哪個類型的時候，我們只能訪問此聯合類型的所有類型中共有的屬性或方法。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Cat</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">run</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Fish</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">swim</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getName</span>(<span class=\"hljs-params\">animal: Cat | Fish</span>) {\n    <span class=\"hljs-keyword\">return</span> animal.<span class=\"hljs-property\">name</span>;\n}\n</code></pre>\n<p>在還不確定類型的時候就訪問其中一個類型特有的屬性或方法，會報錯。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Cat</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">run</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Fish</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">swim</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n\n<span class=\"hljs-comment\">// error: Cat 不存在 swim 方法</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isFish</span>(<span class=\"hljs-params\">animal: Cat | Fish</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> animal.<span class=\"hljs-property\">swim</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n\n<span class=\"hljs-comment\">// Property &#x27;swim&#x27; does not exist on type &#x27;Cat | Fish&#x27;.</span>\n<span class=\"hljs-comment\">//   Property &#x27;swim&#x27; does not exist on type &#x27;Cat&#x27;.</span>\n</code></pre>\n<p>使用斷言改寫後，解決訪問 animal.swim 時報錯的問題。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Cat</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">run</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Fish</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">swim</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isFish</span>(<span class=\"hljs-params\">animal: Cat | Fish</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> (animal <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Fish</span>).<span class=\"hljs-property\">swim</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n<div class=\"warning\">\n<p>類型斷言只能夠「欺騙」TypeScript 編譯器，無法避免運行時的錯誤，反而濫用類型斷言可能會導致運行時錯誤：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Cat</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">run</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Fish</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">swim</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">swim</span>(<span class=\"hljs-params\">animal: Cat | Fish</span>) {\n    (animal <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Fish</span>).<span class=\"hljs-title function_\">swim</span>();\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tom</span>: <span class=\"hljs-title class_\">Cat</span> = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Tom&#x27;</span>,\n    <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;run&#x27;</span>) }\n};\n\n<span class=\"hljs-comment\">// tom 型別是 Cat，沒有型別 Fish 的 swim 方法</span>\n<span class=\"hljs-title function_\">swim</span>(tom);\n\n<span class=\"hljs-comment\">// 編譯時不會報錯，但在運行時會報錯</span>\n<span class=\"hljs-comment\">// Uncaught TypeError: animal.swim is not a function`</span>\n</code></pre>\n<p>原因是 <code>(animal as Fish).swim()</code> 這段代碼隱藏了 <code>animal</code> 可能為 <code>Cat</code> 的情況，將 <code>animal</code> 直接斷言為 <code>Fish</code> 了，<code>而TypeScript</code> 編譯器信任了我們的斷言，故在調用 <code>swim()</code> 時沒有編譯錯誤。<br />\n<br/><br />\n使用類型斷言時一定要格外小心，盡量避免斷言後調用方法或引用深層屬性，以減少不必要的運行時錯誤。</p>\n</div>\n<h4>將一個父類斷言為更加具體的子類</h4>\n<p>當類之間有繼承關係時，類型斷言也是很常見的</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApiError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Error</span> {\n    <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HttpError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Error</span> {\n    <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">200</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isApiError</span>(<span class=\"hljs-params\">error: <span class=\"hljs-built_in\">Error</span></span>) {\n    <span class=\"hljs-comment\">// 判斷傳入的參數是不是 ApiError 型別</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> (error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ApiError</span>).<span class=\"hljs-property\">code</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n<p>聲明了函數 <code>isApiError</code>，它用來判斷傳入的參數是不是 <code>ApiError</code> 型別，為了實現這樣一個函數，它的參數的型別肯定得是比較抽象的父類 <code>Error</code>，這樣的話這個函數就能接受 <code>Error</code> 或它的子類作為參數了。</p>\n<p>但是由於父類 <code>Error</code> 中沒有 <code>code</code> 屬性，故直接獲取 <code>error.code</code> 會報錯，需要使用類型斷言獲取 <code>(error as ApiError).code</code>。</p>\n<div class=\"info\">\n<p><strong>class 情境：</strong>(優先推薦使用 <strong><code>instanceof</code></strong>)</p>\n<p>因 <code>ApiError</code> 是 <strong><code>class</code></strong> 的緣故，這裡也可使用 <strong><code>instanceof</code></strong> 來判斷 <code>error</code> 是否是它的實例。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApiError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Error</span> {\n    <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HttpError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Error</span> {\n    <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">200</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isApiError</span>(<span class=\"hljs-params\">error: <span class=\"hljs-built_in\">Error</span></span>) {\n    <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ApiError</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n</div>\n<div class=\"info\">\n<p><strong>interface 情境：</strong>(使用 <strong>斷言</strong>)</p>\n<p><code>ApiError</code> 和 <code>HttpError</code> 不是一個真正的 <code>class</code>，而只是一個 TypeScript 的接口（interface），接口是一個型別，不是一個真正的值，它在編譯結果中會被刪除，當然就無法使用 <code>instanceof</code> 來做運行時判斷了。</p>\n<br/>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// wrong</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ApiError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HttpError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isApiError</span>(<span class=\"hljs-params\">error: <span class=\"hljs-built_in\">Error</span></span>) {\n    <span class=\"hljs-comment\">// ApiError 為型別，不是真正的值</span>\n    <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ApiError</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n<span class=\"hljs-comment\">// &#x27;ApiError&#x27; only refers to a type, but is being used as a value here.</span>\n</code></pre>\n<p>只能用型別斷言，通過判斷是否存在 <code>code</code> 屬性，來判斷傳入的參數的型別是不是 <code>ApiError</code>。<br />\n<br/></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// correct</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ApiError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HttpError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isApiError</span>(<span class=\"hljs-params\">error: <span class=\"hljs-built_in\">Error</span></span>) {\n    <span class=\"hljs-comment\">// 用類型斷言判斷傳入的參數型別是不是 ApiError</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> (error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ApiError</span>).<span class=\"hljs-property\">code</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n</div>\n<h4>將任何一個型別斷言為 <code>any</code> (pending</h4>\n<p><strong>它極有可能掩蓋了真正的型別錯誤，所以如果不是非常確定，就不要使用 <code>as any</code>。</strong></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// error: window 上不存在 foo 屬性</span>\n<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">// Property &#x27;foo&#x27; does not exist on type &#x27;Window &amp; typeof globalThis&#x27;.</span>\n</code></pre>\n<p>需要將 window 上添加一個屬性 foo，但 TypeScript 編譯時會報錯，提示我們 window 上不存在 foo 屬性。</p>\n<pre class=\"hljs\"><code>(<span class=\"hljs-variable language_\">window</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).<span class=\"hljs-property\">foo</span> = <span class=\"hljs-number\">1</span>;\n</code></pre>\n<p>使用 <code>as any</code> 臨時將 <code>window</code> 斷言為 <code>any</code> 型別，在 <code>any</code> 型別的變量上，訪問任何屬性都是允許的。</p>\n<h4>將 <code>any</code> 斷言為一個具體的型別</h4>\n<p>下面三種情境都有可能受到 TypeScript 型別系統的限制而無法精確定義型別，這時就會處理 <code>any</code> 型別的變量。</p>\n<ul>\n<li>第三方庫未能定義好自己的型別</li>\n<li>前人遺留的代碼</li>\n<li><code>JavaScript</code> 到 <code>TypeScript</code> 的過渡期</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 舊 code，返回值是 any</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getCacheData</span>(<span class=\"hljs-params\">key: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">any</span> {\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-variable language_\">window</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).<span class=\"hljs-property\">cache</span>[key];\n}\n\n<span class=\"hljs-comment\">// 目標： 將返回值斷言成一個精確的類型</span>\n</code></pre>\n<p>通過型別斷言把 <code>any</code> 斷言為精確的型別，亡羊補牢，使我們的代碼向著高可維護性的目標發展。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getCacheData</span>(<span class=\"hljs-params\">key: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">any</span> {\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-variable language_\">window</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).<span class=\"hljs-property\">cache</span>[key];\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Cat</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-title function_\">run</span>(): <span class=\"hljs-built_in\">void</span>;\n}\n\n<span class=\"hljs-comment\">// 調用了它之後的返回值斷言成一個精確的類型 Cat</span>\n<span class=\"hljs-keyword\">const</span> tom = <span class=\"hljs-title function_\">getCacheData</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Cat</span>;\ntom.<span class=\"hljs-title function_\">run</span>();\n</code></pre>\n<p>調用完 <code>getCacheData</code> 之後，立即將它斷言為 <code>Cat</code> 類型。這樣的話明確了 <code>tom</code> 的類型，後續對 <code>tom</code> 的訪問時就有了代碼補全，提高了代碼的可維護性。</p>\n","toc":{"title":"[Note] TypeScript - The Basic Types","subtitles":["Why TypeScript?","原始資料型別 - The primitives","任意值 - any","型別註解 - Type Annotation","型別推論 - Type Inference","聯合型別 - Union Types","物件的型別 介面 - Interface","陣列的型別 - Array","函式的型別 - Function Types","型別斷言 - Type Assertion"]},"wordCount":3915}